<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JDBCProductIndex.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pdl</a> &gt; <a href="index.source.html" class="el_package">gov.usgs.earthquake.indexer</a> &gt; <span class="el_source">JDBCProductIndex.java</span></div><h1>JDBCProductIndex.java</h1><pre class="source lang-java linenums">/*
 * JDBCProductIndex
 */
package gov.usgs.earthquake.indexer;

import gov.usgs.earthquake.product.InvalidProductException;
import gov.usgs.earthquake.product.Product;
import gov.usgs.earthquake.product.ProductId;
import gov.usgs.earthquake.util.JDBCConnection;
import gov.usgs.util.Config;
import gov.usgs.util.JDBCUtils;
import gov.usgs.util.StreamUtils;

import java.io.File;
import java.math.BigDecimal;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * JDBC Implementation of {@link ProductIndex}.
 */
public class JDBCProductIndex extends JDBCConnection implements ProductIndex {

	/** Logging Utility **/
<span class="fc" id="L43">	private static final Logger LOGGER = Logger.getLogger(Indexer.class</span>
<span class="fc" id="L44">			.getName());</span>

	/** _____ First, set up some constants _____ */

	/**
	 * Default index file. Copied into file system as JDBC_DEFAULT_FILE if
	 * doesn't already exist.
	 */
	private static final String JDBC_DEFAULT_INDEX = &quot;etc/schema/productIndex.db&quot;;

	private static final String JDBC_DEFAULT_DRIVER = JDBCUtils.SQLITE_DRIVER_CLASSNAME;

	/**
	 * Default index file. Created by copying JDBC_DEFAULT_INDEX out of Jar if
	 * doesn't already exist in file system
	 */
	public static final String JDBC_DEFAULT_FILE = &quot;productIndex.db&quot;;

	/**
	 * Constant used to specify what the driver property should be called in the
	 * config file
	 */
	private static final String JDBC_DRIVER_PROPERTY = &quot;driver&quot;;

	/**
	 * Constant used to specify the url property should be called in the config
	 * file.
	 */
	private static final String JDBC_URL_PROPERTY = &quot;url&quot;;

	/**
	 * Constant used to specify what the index file property should be called in
	 * to config file
	 */
	private static final String JDBC_FILE_PROPERTY = &quot;indexfile&quot;;

	/** Prefix for connecting to a sqlite database */
	private static final String JDBC_CONNECTION_PREFIX = &quot;jdbc:sqlite:&quot;;

	/** Variables to store the event and product column names */
	private static final String EVENT_TABLE = &quot;event&quot;;
	private static final String EVENT_TABLE_ALIAS = &quot;e&quot;;
	private static final String EVENT_INDEX_ID = &quot;id&quot;;
	private static final String EVENT_CREATED = &quot;created&quot;;
	private static final String EVENT_UPDATED = &quot;updated&quot;;
	private static final String EVENT_SOURCE = &quot;source&quot;;
	private static final String EVENT_SOURCE_CODE = &quot;sourceCode&quot;;
	private static final String EVENT_TIME = &quot;eventTime&quot;;
	private static final String EVENT_LATITUDE = &quot;latitude&quot;;
	private static final String EVENT_LONGITUDE = &quot;longitude&quot;;
	private static final String EVENT_DEPTH = &quot;depth&quot;;
	private static final String EVENT_MAGNITUDE = &quot;magnitude&quot;;
	private static final String EVENT_STATUS = &quot;status&quot;;

	private static final String EVENT_STATUS_UPDATE = &quot;UPDATE&quot;;
	private static final String EVENT_STATUS_DELETE = &quot;DELETE&quot;;

	private static final String SUMMARY_TABLE = &quot;productSummary&quot;;
	private static final String SUMMARY_TABLE_ALIAS = &quot;p&quot;;
	private static final String SUMMARY_CREATED = &quot;created&quot;;
	public static final String SUMMARY_PRODUCT_INDEX_ID = &quot;id&quot;;
	private static final String SUMMARY_PRODUCT_ID = &quot;productId&quot;;
	private static final String SUMMARY_EVENT_ID = &quot;eventId&quot;;
	private static final String SUMMARY_TYPE = &quot;type&quot;;
	private static final String SUMMARY_SOURCE = &quot;source&quot;;
	private static final String SUMMARY_CODE = &quot;code&quot;;
	private static final String SUMMARY_UPDATE_TIME = &quot;updateTime&quot;;
	private static final String SUMMARY_EVENT_SOURCE = &quot;eventSource&quot;;
	private static final String SUMMARY_EVENT_SOURCE_CODE = &quot;eventSourceCode&quot;;
	private static final String SUMMARY_EVENT_TIME = &quot;eventTime&quot;;
	private static final String SUMMARY_EVENT_LATITUDE = &quot;eventLatitude&quot;;
	private static final String SUMMARY_EVENT_LONGITUDE = &quot;eventLongitude&quot;;
	private static final String SUMMARY_EVENT_DEPTH = &quot;eventDepth&quot;;
	private static final String SUMMARY_EVENT_MAGNITUDE = &quot;eventMagnitude&quot;;
	private static final String SUMMARY_VERSION = &quot;version&quot;;
	private static final String SUMMARY_STATUS = &quot;status&quot;;
	private static final String SUMMARY_TRACKER_URL = &quot;trackerURL&quot;;
	private static final String SUMMARY_PREFERRED = &quot;preferred&quot;;
	private static final String SUMMARY_PROPERTY_TABLE = &quot;productSummaryProperty&quot;;
	private static final String SUMMARY_PROPERTY_ID = &quot;productSummaryIndexId&quot;;
	private static final String SUMMARY_PROPERTY_NAME = &quot;name&quot;;
	private static final String SUMMARY_PROPERTY_VALUE = &quot;value&quot;;
	private static final String SUMMARY_LINK_TABLE = &quot;productSummaryLink&quot;;
	private static final String SUMMARY_LINK_ID = &quot;productSummaryIndexId&quot;;
	private static final String SUMMARY_LINK_RELATION = &quot;relation&quot;;
	private static final String SUMMARY_LINK_URL = &quot;url&quot;;

	/** Query used to insert events */
<span class="fc" id="L132">	private static final String INSERT_EVENT_QUERY = String.format(</span>
			&quot;INSERT INTO %s (%s) VALUES (?)&quot;, EVENT_TABLE, EVENT_CREATED);

	/** Query used to update preferred event properties. */
<span class="fc" id="L136">	private static final String UPDATE_EVENT_QUERY = String</span>
<span class="fc" id="L137">			.format(&quot;UPDATE %s SET %s=?, %s=?, %s=?, %s=?, %s=?, %s=?, %s=?, %s=?, %s=? WHERE %s=?&quot;,</span>
					EVENT_TABLE, EVENT_UPDATED, EVENT_SOURCE,
					EVENT_SOURCE_CODE, EVENT_TIME, EVENT_LATITUDE,
					EVENT_LONGITUDE, EVENT_DEPTH, EVENT_MAGNITUDE,
					EVENT_STATUS, EVENT_INDEX_ID);

	/** Query used to update preferred event properties. */
<span class="fc" id="L144">	private static final String UPDATE_DELETED_EVENT_QUERY = String.format(</span>
			&quot;UPDATE %s SET %s=? WHERE %s=?&quot;, EVENT_TABLE, EVENT_STATUS,
			EVENT_INDEX_ID);

	/** Query used to insert product summaries */
<span class="fc" id="L149">	private static final String INSERT_SUMMARY_QUERY = String</span>
<span class="fc" id="L150">			.format(&quot;INSERT INTO %s ( %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s ) &quot;</span>
					+ &quot;VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )&quot;,
					SUMMARY_TABLE, SUMMARY_CREATED, SUMMARY_PRODUCT_ID,
					SUMMARY_TYPE, SUMMARY_SOURCE, SUMMARY_CODE,
					SUMMARY_UPDATE_TIME, SUMMARY_EVENT_SOURCE,
					SUMMARY_EVENT_SOURCE_CODE, SUMMARY_EVENT_TIME,
					SUMMARY_EVENT_LATITUDE, SUMMARY_EVENT_LONGITUDE,
					SUMMARY_EVENT_DEPTH, SUMMARY_EVENT_MAGNITUDE,
					SUMMARY_VERSION, SUMMARY_STATUS, SUMMARY_TRACKER_URL,
					SUMMARY_PREFERRED);

	/** Query used to store the property */
<span class="fc" id="L162">	private static final String ADD_PROPERTY_QUERY = String.format(</span>
			&quot;INSERT INTO %s ( %s, %s, %s ) &quot; + &quot;VALUES (?, ?, ?)&quot;,
			SUMMARY_PROPERTY_TABLE, SUMMARY_PROPERTY_ID, SUMMARY_PROPERTY_NAME,
			SUMMARY_PROPERTY_VALUE);

	/** Query used to store the link */
<span class="fc" id="L168">	private static final String ADD_LINK_QUERY = String.format(</span>
			&quot;INSERT INTO %s ( %s, %s, %s ) &quot; + &quot;VALUES (?, ?, ?)&quot;,
			SUMMARY_LINK_TABLE, SUMMARY_LINK_ID, SUMMARY_LINK_RELATION,
			SUMMARY_LINK_URL);

	/** Query used to store the relation between products and events */
<span class="fc" id="L174">	private static final String ADD_ASSOCIATION_QUERY = String.format(</span>
			&quot;UPDATE %s SET %s=? WHERE %s=? AND %s=? AND %s=?&quot;, SUMMARY_TABLE,
			SUMMARY_EVENT_ID, SUMMARY_SOURCE, SUMMARY_TYPE, SUMMARY_CODE);

	/** Query to delete events */
<span class="fc" id="L179">	private static final String DELETE_EVENT_QUERY = String.format(</span>
			&quot;DELETE FROM %s WHERE id=?&quot;, EVENT_TABLE);

	/** Query to delete products */
<span class="fc" id="L183">	private static final String DELETE_SUMMARY_QUERY = String.format(</span>
			&quot;DELETE FROM %s WHERE id=?&quot;, SUMMARY_TABLE);

	/** Query to delete properties */
<span class="fc" id="L187">	private static final String DELETE_PROPERTIES_QUERY = String.format(</span>
			&quot;DELETE FROM %s WHERE %s=?&quot;, SUMMARY_PROPERTY_TABLE,
			SUMMARY_PROPERTY_ID);

	/** Query to delete links */
<span class="fc" id="L192">	private static final String DELETE_LINKS_QUERY = String.format(</span>
			&quot;DELETE FROM %s WHERE %s=?&quot;, SUMMARY_LINK_TABLE, SUMMARY_LINK_ID);

	/** Query to remove the association between a product and an event */
<span class="fc" id="L196">	private static final String REMOVE_ASSOCIATION_QUERY = String.format(</span>
			&quot;UPDATE %s SET %s=? WHERE %s=? AND %s=? AND %s=?&quot;, SUMMARY_TABLE,
			SUMMARY_EVENT_ID, SUMMARY_SOURCE, SUMMARY_TYPE, SUMMARY_CODE);

	/** Query to get a summary using its id */
<span class="fc" id="L201">	private static final String GET_SUMMARY_BY_PRODUCT_INDEX_ID = String</span>
<span class="fc" id="L202">			.format(&quot;SELECT %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s FROM %s WHERE %s = ?&quot;,</span>
					SUMMARY_PRODUCT_ID, SUMMARY_TYPE, SUMMARY_SOURCE,
					SUMMARY_CODE, SUMMARY_UPDATE_TIME, SUMMARY_EVENT_SOURCE,
					SUMMARY_EVENT_SOURCE_CODE, SUMMARY_EVENT_TIME,
					SUMMARY_EVENT_LATITUDE, SUMMARY_EVENT_LONGITUDE,
					SUMMARY_EVENT_DEPTH, SUMMARY_EVENT_MAGNITUDE,
					SUMMARY_VERSION, SUMMARY_STATUS, SUMMARY_TRACKER_URL,
					SUMMARY_PREFERRED, SUMMARY_TABLE, SUMMARY_PRODUCT_INDEX_ID);

	/** Query to get product ids that share an event id */
<span class="fc" id="L212">	private static final String GET_SUMMARIES_BY_EVENT_INDEX_ID = String</span>
<span class="fc" id="L213">			.format(&quot;SELECT %s FROM %s WHERE %s = ?&quot;, SUMMARY_PRODUCT_INDEX_ID,</span>
					SUMMARY_TABLE, SUMMARY_EVENT_ID);

	/** Query to get all the links for a product */
<span class="fc" id="L217">	private static final String GET_LINKS_BY_PRODUCT_INDEX_ID = String.format(</span>
			&quot;SELECT %s, %s FROM %s WHERE %s = ?&quot;, SUMMARY_LINK_RELATION,
			SUMMARY_LINK_URL, SUMMARY_LINK_TABLE, SUMMARY_LINK_ID);

	/** Query to get all the properties for a product */
<span class="fc" id="L222">	private static final String GET_PROPS_BY_PRODUCT_INDEX_ID = String</span>
<span class="fc" id="L223">			.format(&quot;SELECT %s, %s FROM %s WHERE %s = ?&quot;,</span>
					SUMMARY_PROPERTY_NAME, SUMMARY_PROPERTY_VALUE,
					SUMMARY_PROPERTY_TABLE, SUMMARY_PROPERTY_ID);

	/** Create some prepared statements */
	private PreparedStatement insertEvent;
	private PreparedStatement updateEvent;
	private PreparedStatement updateDeletedEvent;
	private PreparedStatement insertSummary;
	private PreparedStatement insertProperty;
	private PreparedStatement insertLink;
	private PreparedStatement addAssociation;
	private PreparedStatement deleteEvent;
	private PreparedStatement deleteSummary;
	private PreparedStatement deleteProperties;
	private PreparedStatement deleteLinks;
	private PreparedStatement removeAssociation;
	private PreparedStatement getSummary;
	private PreparedStatement getSummaries;
	private PreparedStatement getProductLinks;
	private PreparedStatement getProductProperties;

	private String driver;
	private String url;
	private String index_file;

	/**
	 * Constructor. Sets index_file to the default value JDBC_DEFAULT_FILE
	 *
	 * @throws Exception
	 */
<span class="fc" id="L254">	public JDBCProductIndex() throws Exception {</span>
		// Default index file, so calling configure() isn't required
<span class="fc" id="L256">		index_file = JDBC_DEFAULT_FILE;</span>
<span class="fc" id="L257">		driver = JDBC_DEFAULT_DRIVER;</span>
<span class="fc" id="L258">	}</span>

<span class="fc" id="L260">	public JDBCProductIndex(final String sqliteFileName) throws Exception {</span>
<span class="fc" id="L261">		index_file = sqliteFileName;</span>
<span class="fc" id="L262">		driver = JDBC_DEFAULT_DRIVER;</span>
<span class="fc" id="L263">	}</span>

	// ____________________________________
	// Public Methods
	// ____________________________________

	/**
	 * Grab values from the Config object and put them into private variables.
	 *
	 * @param config
	 *            Configuration for the product index
	 */
	@Override
	public void configure(Config config) throws Exception {

<span class="fc" id="L278">		driver = config.getProperty(JDBC_DRIVER_PROPERTY);</span>
<span class="fc" id="L279">		index_file = config.getProperty(JDBC_FILE_PROPERTY);</span>
<span class="fc" id="L280">		url = config.getProperty(JDBC_URL_PROPERTY);</span>

<span class="pc bpc" id="L282" title="3 of 4 branches missed.">		if (driver == null || &quot;&quot;.equals(driver)) {</span>
<span class="fc" id="L283">			driver = JDBC_DEFAULT_DRIVER;</span>
		}

<span class="pc bpc" id="L286" title="3 of 4 branches missed.">		if (index_file == null || &quot;&quot;.equals(index_file)) {</span>
<span class="fc" id="L287">			index_file = JDBC_DEFAULT_FILE;</span>
		}
<span class="fc" id="L289">	}</span>

	/**
	 * Connect to the database and set up some prepared statements
	 */
	@Override
	public synchronized void startup() throws Exception {
		// initialize connection
<span class="fc" id="L297">		super.startup();</span>
<span class="fc" id="L298">		Connection connection = getConnection();</span>

		// Prepare statements for interacting with the database
		try {
<span class="fc" id="L302">			insertEvent = connection.prepareStatement(INSERT_EVENT_QUERY,</span>
					new String[] { EVENT_INDEX_ID });
<span class="nc" id="L304">		} catch (SQLException e) {</span>
			// sqlite doesn't support RETURN_GENERATED_KEYS, but appears to
			// return generated keys anyways
<span class="nc" id="L307">			insertEvent = connection.prepareStatement(INSERT_EVENT_QUERY);</span>
<span class="fc" id="L308">		}</span>
<span class="fc" id="L309">		updateEvent = connection.prepareStatement(UPDATE_EVENT_QUERY);</span>
<span class="fc" id="L310">		updateDeletedEvent = connection</span>
<span class="fc" id="L311">				.prepareStatement(UPDATE_DELETED_EVENT_QUERY);</span>
		try {
<span class="fc" id="L313">			insertSummary = connection.prepareStatement(INSERT_SUMMARY_QUERY,</span>
					new String[] { SUMMARY_PRODUCT_INDEX_ID });
<span class="nc" id="L315">		} catch (SQLException e) {</span>
			// sqlite doesn't support RETURN_GENERATED_KEYS, but appears to
			// return generated keys anyways
<span class="nc" id="L318">			insertSummary = connection.prepareStatement(INSERT_SUMMARY_QUERY);</span>
<span class="fc" id="L319">		}</span>
<span class="fc" id="L320">		insertProperty = connection.prepareStatement(ADD_PROPERTY_QUERY);</span>
<span class="fc" id="L321">		insertLink = connection.prepareStatement(ADD_LINK_QUERY);</span>
<span class="fc" id="L322">		deleteEvent = connection.prepareStatement(DELETE_EVENT_QUERY);</span>
<span class="fc" id="L323">		deleteSummary = connection.prepareStatement(DELETE_SUMMARY_QUERY);</span>
<span class="fc" id="L324">		deleteProperties = connection.prepareStatement(DELETE_PROPERTIES_QUERY);</span>
<span class="fc" id="L325">		deleteLinks = connection.prepareStatement(DELETE_LINKS_QUERY);</span>
<span class="fc" id="L326">		removeAssociation = connection</span>
<span class="fc" id="L327">				.prepareStatement(REMOVE_ASSOCIATION_QUERY);</span>
<span class="fc" id="L328">		addAssociation = connection.prepareStatement(ADD_ASSOCIATION_QUERY);</span>
<span class="fc" id="L329">		getSummary = connection</span>
<span class="fc" id="L330">				.prepareStatement(GET_SUMMARY_BY_PRODUCT_INDEX_ID);</span>
<span class="fc" id="L331">		getSummaries = connection</span>
<span class="fc" id="L332">				.prepareStatement(GET_SUMMARIES_BY_EVENT_INDEX_ID);</span>
<span class="fc" id="L333">		getProductLinks = connection</span>
<span class="fc" id="L334">				.prepareStatement(GET_LINKS_BY_PRODUCT_INDEX_ID);</span>
<span class="fc" id="L335">		getProductProperties = connection</span>
<span class="fc" id="L336">				.prepareStatement(GET_PROPS_BY_PRODUCT_INDEX_ID);</span>
<span class="fc" id="L337">	}</span>

	/**
	 * Return a connection to the database.
	 *
	 * @return Connection object
	 * @throws Exception
	 */
	@Override
	public Connection connect() throws Exception {
		// If they are using the sqlite driver, we need to try to create the
		// file
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">		if (driver.equals(JDBCUtils.SQLITE_DRIVER_CLASSNAME)) {</span>
			// Make sure file exists or copy it out of the JAR
<span class="fc" id="L351">			File indexFile = new File(index_file);</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">			if (!indexFile.exists()) {</span>
				// extract schema from jar
<span class="fc" id="L354">				URL schemaURL = JDBCProductIndex.class.getClassLoader()</span>
<span class="fc" id="L355">						.getResource(JDBC_DEFAULT_INDEX);</span>
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">				if (schemaURL != null) {</span>
<span class="nc" id="L357">					StreamUtils.transferStream(schemaURL, indexFile);</span>
				} else {
					// Failed. Probably because we're not in a Jar file
<span class="fc" id="L360">					File defaultIndex = new File(JDBC_DEFAULT_INDEX);</span>
<span class="fc" id="L361">					StreamUtils.transferStream(defaultIndex, indexFile);</span>
				}
			}
<span class="fc" id="L364">			indexFile = null;</span>

			// Build the JDBC url
<span class="fc" id="L367">			url = JDBC_CONNECTION_PREFIX + index_file;</span>
<span class="fc" id="L368">			driver = JDBCUtils.SQLITE_DRIVER_CLASSNAME;</span>
		}

<span class="fc" id="L371">		return JDBCUtils.getConnection(driver, url);</span>
	}

	/**
	 * Close the database connection and each of the prepared statements. Before
	 * closing each resource, this method checks if it is already closed.
	 */
	@Override
	public synchronized void shutdown() throws Exception {
		// Close each of the prepared statements, then close the connection.
		// Make sure exceptions don't prevent closing of any statements.

<span class="fc bfc" id="L383" title="All 2 branches covered.">		if (insertEvent != null) {</span>
			try {
<span class="fc" id="L385">				insertEvent.close();</span>
<span class="nc" id="L386">			} catch (Exception e) {</span>
				// ignore
<span class="fc" id="L388">			}</span>
<span class="fc" id="L389">			insertEvent = null;</span>
		}

<span class="fc bfc" id="L392" title="All 2 branches covered.">		if (updateEvent != null) {</span>
			try {
<span class="fc" id="L394">				updateEvent.close();</span>
<span class="nc" id="L395">			} catch (Exception e) {</span>
				// ignore
<span class="fc" id="L397">			}</span>
<span class="fc" id="L398">			updateEvent = null;</span>
		}

<span class="fc bfc" id="L401" title="All 2 branches covered.">		if (updateDeletedEvent != null) {</span>
			try {
<span class="fc" id="L403">				updateDeletedEvent.close();</span>
<span class="nc" id="L404">			} catch (Exception e) {</span>
				// ignore
<span class="fc" id="L406">			}</span>
<span class="fc" id="L407">			updateDeletedEvent = null;</span>
		}

<span class="fc bfc" id="L410" title="All 2 branches covered.">		if (insertSummary != null) {</span>
			try {
<span class="fc" id="L412">				insertSummary.close();</span>
<span class="nc" id="L413">			} catch (Exception e) {</span>
				// ignore
<span class="fc" id="L415">			}</span>
<span class="fc" id="L416">			insertSummary = null;</span>
		}

<span class="fc bfc" id="L419" title="All 2 branches covered.">		if (insertProperty != null) {</span>
			try {
<span class="fc" id="L421">				insertProperty.close();</span>
<span class="nc" id="L422">			} catch (Exception e) {</span>
				// ignore
<span class="fc" id="L424">			}</span>
<span class="fc" id="L425">			insertProperty = null;</span>
		}

<span class="fc bfc" id="L428" title="All 2 branches covered.">		if (insertLink != null) {</span>
			try {
<span class="fc" id="L430">				insertLink.close();</span>
<span class="nc" id="L431">			} catch (Exception e) {</span>
				// ignore
<span class="fc" id="L433">			}</span>
<span class="fc" id="L434">			insertLink = null;</span>
		}

<span class="fc bfc" id="L437" title="All 2 branches covered.">		if (deleteEvent != null) {</span>
			try {
<span class="fc" id="L439">				deleteEvent.close();</span>
<span class="nc" id="L440">			} catch (Exception e) {</span>
				// ignore
<span class="fc" id="L442">			}</span>
<span class="fc" id="L443">			deleteEvent = null;</span>
		}

<span class="fc bfc" id="L446" title="All 2 branches covered.">		if (deleteSummary != null) {</span>
			try {
<span class="fc" id="L448">				deleteSummary.close();</span>
<span class="nc" id="L449">			} catch (Exception e) {</span>
				// ignore
<span class="fc" id="L451">			}</span>
<span class="fc" id="L452">			deleteSummary = null;</span>
		}

<span class="fc bfc" id="L455" title="All 2 branches covered.">		if (deleteProperties != null) {</span>
			try {
<span class="fc" id="L457">				deleteProperties.close();</span>
<span class="nc" id="L458">			} catch (Exception e) {</span>
				// ignore
<span class="fc" id="L460">			}</span>
<span class="fc" id="L461">			deleteProperties = null;</span>
		}

<span class="fc bfc" id="L464" title="All 2 branches covered.">		if (deleteLinks != null) {</span>
			try {
<span class="fc" id="L466">				deleteLinks.close();</span>
<span class="nc" id="L467">			} catch (Exception e) {</span>
				// ignore
<span class="fc" id="L469">			}</span>
<span class="fc" id="L470">			deleteLinks = null;</span>
		}

<span class="fc bfc" id="L473" title="All 2 branches covered.">		if (removeAssociation != null) {</span>
			try {
<span class="fc" id="L475">				removeAssociation.close();</span>
<span class="nc" id="L476">			} catch (Exception e) {</span>
				// ignore
<span class="fc" id="L478">			}</span>
<span class="fc" id="L479">			removeAssociation = null;</span>
		}

<span class="fc bfc" id="L482" title="All 2 branches covered.">		if (addAssociation != null) {</span>
			try {
<span class="fc" id="L484">				addAssociation.close();</span>
<span class="nc" id="L485">			} catch (Exception e) {</span>
				// ignore
<span class="fc" id="L487">			}</span>
<span class="fc" id="L488">			addAssociation = null;</span>
		}

<span class="fc bfc" id="L491" title="All 2 branches covered.">		if (getSummary != null) {</span>
			try {
<span class="fc" id="L493">				getSummary.close();</span>
<span class="nc" id="L494">			} catch (Exception e) {</span>
				// ignore
<span class="fc" id="L496">			}</span>
<span class="fc" id="L497">			getSummary = null;</span>
		}

<span class="fc bfc" id="L500" title="All 2 branches covered.">		if (getSummaries != null) {</span>
			try {
<span class="fc" id="L502">				getSummaries.close();</span>
<span class="nc" id="L503">			} catch (Exception e) {</span>
				// ignore
<span class="fc" id="L505">			}</span>
<span class="fc" id="L506">			getSummaries = null;</span>
		}

<span class="fc bfc" id="L509" title="All 2 branches covered.">		if (getProductLinks != null) {</span>
			try {
<span class="fc" id="L511">				getProductLinks.close();</span>
<span class="nc" id="L512">			} catch (Exception e) {</span>
				// ignore
<span class="fc" id="L514">			}</span>
<span class="fc" id="L515">			getProductLinks = null;</span>
		}

<span class="fc bfc" id="L518" title="All 2 branches covered.">		if (getProductProperties != null) {</span>
			try {
<span class="fc" id="L520">				getProductProperties.close();</span>
<span class="nc" id="L521">			} catch (Exception e) {</span>
				// ignore
<span class="fc" id="L523">			}</span>
<span class="fc" id="L524">			getProductProperties = null;</span>
		}

		// disconnect
<span class="fc" id="L528">		super.shutdown();</span>
<span class="fc" id="L529">	}</span>

	/**
	 * Return all events from the database that meet the parameters specified in
	 * the ProductIndexQuery object.
	 *
	 * @param query
	 *            A description of which events to retrieve.
	 * @return List of Event objects
	 */
	@Override
	public synchronized List&lt;Event&gt; getEvents(ProductIndexQuery query)
			throws Exception {
<span class="fc" id="L542">		List&lt;Event&gt; events = new LinkedList&lt;Event&gt;();</span>

		// Get a list of event indexIds from the database that match this query
<span class="fc" id="L545">		List&lt;Long&gt; eventIndexIds = getEventIndexIds(query);</span>

<span class="fc" id="L547">		Iterator&lt;Long&gt; iter = eventIndexIds.iterator();</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">		while (iter.hasNext()) {</span>
<span class="fc" id="L549">			Long eventIndexId = iter.next();</span>
<span class="fc" id="L550">			events.add(getEvent(eventIndexId));</span>
<span class="fc" id="L551">		}</span>

<span class="fc" id="L553">		return events;</span>
	}

	/**
	 * Add an event to the database
	 *
	 * @param event
	 *            Event to store
	 * @return Event object with eventId set to the database id
	 */
	@Override
	public synchronized Event addEvent(Event event) throws Exception {
<span class="fc" id="L565">		Event e = null;</span>
<span class="fc" id="L566">		ResultSet keys = null;</span>

		try {
			// Add the values to the prepared statement
<span class="fc" id="L570">			JDBCUtils.setParameter(insertEvent, 1, new Date().getTime(),</span>
					Types.BIGINT);

			// Execute the prepared statement
<span class="fc" id="L574">			int rows = insertEvent.executeUpdate();</span>

<span class="pc bpc" id="L576" title="1 of 2 branches missed.">			if (rows == 1) {</span>
<span class="fc" id="L577">				keys = insertEvent.getGeneratedKeys();</span>
<span class="fc" id="L578">				long id = 0;</span>
<span class="fc bfc" id="L579" title="All 2 branches covered.">				while (keys.next()) {</span>
<span class="fc" id="L580">					id = keys.getLong(1);</span>
				}
<span class="fc" id="L582">				e = new Event(event);</span>
<span class="fc" id="L583">				e.setIndexId(id);</span>

<span class="fc" id="L585">				LOGGER.finest(&quot;Added event id=&quot; + id);</span>
<span class="fc" id="L586">			} else {</span>
<span class="nc" id="L587">				LOGGER.log(Level.WARNING, &quot;[&quot; + getName()</span>
						+ &quot;] Exception when adding new event to database&quot;);
<span class="nc" id="L589">				throw new Exception();</span>

			}
		} finally {
			try {
<span class="fc" id="L594">				keys.close();</span>
<span class="nc" id="L595">			} catch (Exception e2) {</span>
<span class="fc" id="L596">			}</span>
		}
<span class="fc" id="L598">		LOGGER.log(Level.FINEST, &quot;[&quot; + getName()</span>
				+ &quot;] Added event to Product Index&quot;);
<span class="fc" id="L600">		return e;</span>
	}

	/**
	 * Delete an event from the database.
	 *
	 * @param event
	 *            Event to remove
	 * @return List containing all the ProductIds that were deleted by the
	 *         method call
	 */
	@Override
	public synchronized List&lt;ProductId&gt; removeEvent(Event event)
			throws Exception {

<span class="fc" id="L615">		Long id = event.getIndexId();</span>

		// If there is no index id on the event, we can assume its
		// not in the database
<span class="pc bpc" id="L619" title="1 of 2 branches missed.">		if (id == null) {</span>
<span class="nc" id="L620">			return null;</span>
		}

		// A list of all the productIds that got deleted
<span class="fc" id="L624">		ArrayList&lt;ProductId&gt; productIds = new ArrayList&lt;ProductId&gt;();</span>

		// We need to remove all the products associated with this event
<span class="fc" id="L627">		List&lt;ProductSummary&gt; summaries = event.getProductList();</span>
<span class="fc" id="L628">		Iterator&lt;ProductSummary&gt; summaryIter = summaries.iterator();</span>
<span class="fc bfc" id="L629" title="All 2 branches covered.">		while (summaryIter.hasNext()) {</span>
<span class="fc" id="L630">			ProductId productId = removeProductSummary(summaryIter.next());</span>
<span class="fc" id="L631">			productIds.add(productId);</span>
<span class="fc" id="L632">		}</span>

<span class="fc" id="L634">		JDBCUtils.setParameter(deleteEvent, 1, id, Types.BIGINT);</span>
<span class="fc" id="L635">		int rows = deleteEvent.executeUpdate();</span>
		// If we didn't delete a row, or we deleted more than 1 row, throw an
		// exception
<span class="pc bpc" id="L638" title="1 of 2 branches missed.">		if (rows != 1) {</span>
<span class="nc" id="L639">			LOGGER.log(Level.WARNING, &quot;[&quot; + getName()</span>
					+ &quot;] Exception when deleting an event from the database&quot;);
<span class="nc" id="L641">			throw new Exception();</span>
		}

<span class="fc" id="L644">		LOGGER.finest(&quot;[&quot; + getName() + &quot;] Removed event id=&quot; + id);</span>

<span class="fc" id="L646">		return productIds;</span>
	}

	/**
	 * Return all products that aren't associated with an event.
	 *
	 * @param query
	 *            ProductIndexQuery used to further limit the results
	 * @return List of unassociated Products
	 * @throws IllegalArgumentException
	 *             when query event search type is SEARCH_EVENT_PREFERRED.
	 */
	@Override
	public synchronized List&lt;ProductSummary&gt; getUnassociatedProducts(
			ProductIndexQuery query) throws Exception {
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">		if (query.getEventSearchType() == ProductIndexQuery.SEARCH_EVENT_PREFERRED) {</span>
<span class="nc" id="L662">			throw new IllegalArgumentException(</span>
					&quot;getUnassociatedProducts does not support SEARCH_EVENT_PREFERRED&quot;);
		}

<span class="fc" id="L666">		ArrayList&lt;ProductSummary&gt; products = new ArrayList&lt;ProductSummary&gt;();</span>

<span class="fc" id="L668">		List&lt;String&gt; clauseList = buildProductClauses(query);</span>
		// Add the unassociated quantifier to the clause list
<span class="fc" id="L670">		clauseList.add(&quot;eventId IS NULL&quot;);</span>
<span class="fc" id="L671">		String query_text = buildProductQuery(clauseList);</span>

<span class="fc" id="L673">		Statement statement = null;</span>
<span class="fc" id="L674">		ResultSet results = null;</span>
		try {
			// Great. We have the query built up, so lets run it
<span class="fc" id="L677">			statement = verifyConnection().createStatement();</span>
<span class="fc" id="L678">			results = statement.executeQuery(query_text);</span>

			// Now lets build an Event object from each row in the result set
<span class="fc bfc" id="L681" title="All 2 branches covered.">			while (results.next()) {</span>
<span class="fc" id="L682">				ProductSummary p = parseSummaryResult(results);</span>
<span class="fc" id="L683">				products.add(p);</span>
<span class="fc" id="L684">			}</span>
		} finally {
			try {
<span class="fc" id="L687">				results.close();</span>
<span class="nc" id="L688">			} catch (Exception e) {</span>
<span class="fc" id="L689">			}</span>
			try {
<span class="fc" id="L691">				statement.close();</span>
<span class="nc" id="L692">			} catch (Exception e) {</span>
<span class="fc" id="L693">			}</span>
		}

<span class="fc" id="L696">		return products;</span>
	}

	/**
	 * Return all products that meet the parameters specified in the
	 * ProductIndexQuery object.
	 *
	 * @param query
	 *            A description of which products to retrieve.
	 * @return List of ProductSummary objects
	 * @throws IllegalArgumentException
	 *             when query event search type is SEARCH_EVENT_PREFERRED.
	 */
	@Override
	public synchronized List&lt;ProductSummary&gt; getProducts(ProductIndexQuery query)
			throws Exception {
<span class="pc bpc" id="L712" title="1 of 2 branches missed.">		if (query.getEventSearchType() == ProductIndexQuery.SEARCH_EVENT_PREFERRED) {</span>
<span class="nc" id="L713">			throw new IllegalArgumentException(</span>
					&quot;getUnassociatedProducts does not support SEARCH_EVENT_PREFERRED&quot;);
		}

<span class="fc" id="L717">		List&lt;ProductSummary&gt; summaries = new LinkedList&lt;ProductSummary&gt;();</span>

<span class="fc" id="L719">		Iterator&lt;Long&gt; summaryIndexIds = getSummaryIndexIds(query).iterator();</span>
<span class="fc bfc" id="L720" title="All 2 branches covered.">		while (summaryIndexIds.hasNext()) {</span>
<span class="fc" id="L721">			summaries.add(getSummary(summaryIndexIds.next()));</span>
		}

<span class="fc" id="L724">		return summaries;</span>
	}

	/**
	 * Add a product summary to the database
	 *
	 * @param summary
	 *            ProductSummary object to store. Must not be null.
	 * @return Copy of the product summary object with the indexId set to the
	 *         newly inserted id.
	 * @throws Exception
	 */
	@Override
	public synchronized ProductSummary addProductSummary(ProductSummary summary)
			throws Exception {
		// Add values to the prepared statement

		// Set the created timestamp
<span class="fc" id="L742">		JDBCUtils.setParameter(insertSummary, 1, new Date().getTime(),</span>
				Types.BIGINT);

<span class="fc" id="L745">		ProductId sid = summary.getId();</span>
<span class="pc bpc" id="L746" title="1 of 2 branches missed.">		if (sid != null) {</span>
<span class="fc" id="L747">			JDBCUtils.setParameter(insertSummary, 2, sid.toString(),</span>
					Types.VARCHAR);
<span class="fc" id="L749">			JDBCUtils.setParameter(insertSummary, 3, sid.getType(),</span>
					Types.VARCHAR);
<span class="fc" id="L751">			JDBCUtils.setParameter(insertSummary, 4, sid.getSource(),</span>
					Types.VARCHAR);
<span class="fc" id="L753">			JDBCUtils.setParameter(insertSummary, 5, sid.getCode(),</span>
					Types.VARCHAR);
<span class="fc" id="L755">			JDBCUtils.setParameter(insertSummary, 6,</span>
<span class="pc bpc" id="L756" title="1 of 2 branches missed.">					(sid.getUpdateTime() != null) ? sid.getUpdateTime()</span>
<span class="pc" id="L757">							.getTime() : null, Types.BIGINT);</span>
		} else {
			// Summary product id is null. Set all these parameter to null
<span class="nc" id="L760">			JDBCUtils.setParameter(insertSummary, 2, null, Types.VARCHAR);</span>
<span class="nc" id="L761">			JDBCUtils.setParameter(insertSummary, 3, null, Types.VARCHAR);</span>
<span class="nc" id="L762">			JDBCUtils.setParameter(insertSummary, 4, null, Types.VARCHAR);</span>
<span class="nc" id="L763">			JDBCUtils.setParameter(insertSummary, 5, null, Types.VARCHAR);</span>
<span class="nc" id="L764">			JDBCUtils.setParameter(insertSummary, 6, null, Types.BIGINT);</span>
		}

<span class="fc" id="L767">		JDBCUtils.setParameter(insertSummary, 7, summary.getEventSource(),</span>
				Types.VARCHAR);
<span class="fc" id="L769">		JDBCUtils.setParameter(insertSummary, 8, summary.getEventSourceCode(),</span>
				Types.VARCHAR);

<span class="fc" id="L772">		Date eventTime = summary.getEventTime();</span>
<span class="fc" id="L773">		JDBCUtils.setParameter(insertSummary, 9,</span>
<span class="fc bfc" id="L774" title="All 2 branches covered.">				(eventTime != null) ? eventTime.getTime() : null, Types.BIGINT);</span>

<span class="fc" id="L776">		JDBCUtils</span>
<span class="fc" id="L777">				.setParameter(insertSummary, 10,</span>
<span class="fc bfc" id="L778" title="All 2 branches covered.">						(summary.getEventLatitude() != null) ? summary</span>
<span class="fc" id="L779">								.getEventLatitude().doubleValue() : null,</span>
						Types.DECIMAL);
<span class="fc" id="L781">		JDBCUtils</span>
<span class="fc" id="L782">				.setParameter(</span>
						insertSummary,
						11,
<span class="fc bfc" id="L785" title="All 2 branches covered.">						(summary.getEventLongitude() != null) ? normalizeLongitude(summary</span>
<span class="fc" id="L786">								.getEventLongitude().doubleValue()) : null,</span>
						Types.DECIMAL);
<span class="fc" id="L788">		JDBCUtils.setParameter(insertSummary, 12,</span>
<span class="fc bfc" id="L789" title="All 2 branches covered.">				(summary.getEventDepth() != null) ? summary.getEventDepth()</span>
<span class="fc" id="L790">						.doubleValue() : null, Types.DECIMAL);</span>
<span class="fc" id="L791">		JDBCUtils.setParameter(insertSummary, 13,</span>
<span class="fc bfc" id="L792" title="All 2 branches covered.">				(summary.getEventMagnitude() != null) ? summary</span>
<span class="fc" id="L793">						.getEventMagnitude().doubleValue() : null,</span>
				Types.DECIMAL);
<span class="fc" id="L795">		JDBCUtils.setParameter(insertSummary, 14, summary.getVersion(),</span>
				Types.VARCHAR);
<span class="fc" id="L797">		JDBCUtils.setParameter(insertSummary, 15, summary.getStatus(),</span>
				Types.VARCHAR);
<span class="fc" id="L799">		JDBCUtils.setParameter(insertSummary, 16,</span>
<span class="pc bpc" id="L800" title="1 of 2 branches missed.">				(summary.getTrackerURL() != null) ? summary.getTrackerURL()</span>
<span class="pc" id="L801">						.toString() : null, Types.VARCHAR);</span>
<span class="fc" id="L802">		JDBCUtils.setParameter(insertSummary, 17, summary.getPreferredWeight(),</span>
				Types.BIGINT);

		// Execute the prepared statement
<span class="fc" id="L806">		insertSummary.executeUpdate();</span>

<span class="fc" id="L808">		ResultSet keys = null;</span>
<span class="fc" id="L809">		long productId = 0;</span>

		try {
<span class="fc" id="L812">			keys = insertSummary.getGeneratedKeys();</span>
<span class="fc bfc" id="L813" title="All 2 branches covered.">			while (keys.next()) {</span>
<span class="fc" id="L814">				productId = keys.getLong(1);</span>
			}
		} finally {
			try {
<span class="fc" id="L818">				keys.close();</span>
<span class="nc" id="L819">			} catch (Exception e) {</span>
<span class="fc" id="L820">			}</span>
		}

		// Now that the summary is stored, lets try to store the properties
<span class="fc" id="L824">		addProductProperties(productId, summary.getProperties());</span>
		// And try to store the links
<span class="fc" id="L826">		addProductLinks(productId, summary.getLinks());</span>

<span class="fc" id="L828">		ProductSummary p = new ProductSummary(summary);</span>
<span class="fc" id="L829">		p.setIndexId(productId);</span>

<span class="fc bfc" id="L831" title="All 2 branches covered.">		if (LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="fc" id="L832">			LOGGER.finest(&quot;[&quot; + getName() + &quot;] Added productSummary &quot; + sid</span>
					+ &quot;, indexid=&quot; + productId + &quot; to product index&quot;);
		}
<span class="fc" id="L835">		return p;</span>
	}

	/**
	 * Delete a product summary from the database If the summary doesn't have an
	 * indexId value set, throw an exception
	 *
	 * @param summary
	 *            ProductSummary object to delete
	 */
	@Override
	public synchronized ProductId removeProductSummary(ProductSummary summary)
			throws Exception {
<span class="pc bpc" id="L848" title="2 of 4 branches missed.">		if (summary.getIndexId() != 0 &amp;&amp; summary.getIndexId() != null) {</span>
			// First remove all the properties and links
<span class="fc" id="L850">			long id = summary.getIndexId();</span>
<span class="fc" id="L851">			removeProductProperties(id);</span>
<span class="fc" id="L852">			removeProductLinks(id);</span>

<span class="fc" id="L854">			JDBCUtils.setParameter(deleteSummary, 1, id, Types.BIGINT);</span>
<span class="fc" id="L855">			deleteSummary.executeUpdate();</span>

<span class="fc" id="L857">			LOGGER.finest(&quot;[&quot; + getName() + &quot;] Removed productSummary id=&quot; + id);</span>

			// Return the id of the product deleted
<span class="fc" id="L860">			return summary.getId();</span>
		} else {
<span class="nc" id="L862">			LOGGER.log(Level.WARNING, &quot;[&quot; + getName()</span>
					+ &quot;] Could not delete product summary. Index id not found&quot;);
<span class="nc" id="L864">			throw new Exception(&quot;[&quot; + getName()</span>
					+ &quot;] Could not delete summary. Index id not found.&quot;);
		}
	}

	/**
	 * Create an association between the given event and product summary. This
	 * assumes that both the event and the product are already stored in their
	 * respective tables.
	 *
	 * @param event
	 * @param summary
	 * @return Copy of event with summary added to the event's products list
	 */
	@Override
	public synchronized Event addAssociation(Event event, ProductSummary summary)
			throws Exception {

<span class="pc bpc" id="L882" title="2 of 4 branches missed.">		if (event.getIndexId() == null || summary.getIndexId() == null) {</span>
<span class="nc" id="L883">			throw new Exception(</span>
					&quot;[&quot;
<span class="nc" id="L885">							+ getName()</span>
							+ &quot;] Cannot add association between event or summary that are not already in index.&quot;);
		}

<span class="fc" id="L889">		ProductId sid = summary.getId();</span>

<span class="fc" id="L891">		JDBCUtils.setParameter(addAssociation, 1, event.getIndexId(),</span>
				Types.BIGINT);
		// these will target EVERY version of the given product
<span class="fc" id="L894">		JDBCUtils.setParameter(addAssociation, 2, sid.getSource(),</span>
				Types.VARCHAR);
<span class="fc" id="L896">		JDBCUtils.setParameter(addAssociation, 3, sid.getType(), Types.VARCHAR);</span>
<span class="fc" id="L897">		JDBCUtils.setParameter(addAssociation, 4, sid.getCode(), Types.VARCHAR);</span>

<span class="fc" id="L899">		addAssociation.executeUpdate();</span>
<span class="fc" id="L900">		Event e = new Event(event);</span>
<span class="fc" id="L901">		e.addProduct(summary);</span>
<span class="fc" id="L902">		LOGGER.log(</span>
				Level.FINER,
<span class="fc" id="L904">				&quot;[&quot; + getName() + &quot;] Added associations event id=&quot;</span>
<span class="fc" id="L905">						+ event.getIndexId() + &quot;, productSummary source=&quot;</span>
<span class="fc" id="L906">						+ sid.getSource() + &quot;, type=&quot; + sid.getType()</span>
<span class="fc" id="L907">						+ &quot;, code=&quot; + sid.getCode() + &quot; (id=&quot;</span>
<span class="fc" id="L908">						+ summary.getIndexId() + &quot;)&quot;);</span>

<span class="fc" id="L910">		return e;</span>
	}

	/**
	 * Delete the association, if it exists, between the given event and product
	 * summary.
	 *
	 * NOTE: this removes the association between the event and ALL versions of the product summary.
	 *
	 * @param event
	 * @param summary
	 */
	@Override
	public synchronized Event removeAssociation(Event event,
			ProductSummary summary) throws Exception {

		// Deleting the association is really just removing the foreign key
		// on the products table

		// First check that this summary and event are both in the database

		// What happens if runtime objects are set up, but not added to index.
		// This would return the event with the association in-tact. Is that
		// okay?

<span class="fc" id="L935">		Long eventIndexId = event.getIndexId();</span>
<span class="fc" id="L936">		Long productIndexId = summary.getIndexId();</span>
<span class="pc bpc" id="L937" title="2 of 4 branches missed.">		if (eventIndexId == null || productIndexId == null) {</span>
<span class="nc" id="L938">			return event;</span>
		}

<span class="fc" id="L941">		ProductId sid = summary.getId();</span>

		// Now run the query
<span class="fc" id="L944">		JDBCUtils.setParameter(removeAssociation, 1, null, Types.BIGINT);</span>
		// these will target EVERY version of the given product
<span class="fc" id="L946">		JDBCUtils.setParameter(removeAssociation, 2, summary.getId()</span>
<span class="fc" id="L947">				.getSource(), Types.VARCHAR);</span>
<span class="fc" id="L948">		JDBCUtils.setParameter(removeAssociation, 3, summary.getId().getType(),</span>
				Types.VARCHAR);
<span class="fc" id="L950">		JDBCUtils.setParameter(removeAssociation, 4, summary.getId().getCode(),</span>
				Types.VARCHAR);

<span class="fc" id="L953">		int rows = removeAssociation.executeUpdate();</span>
		// Throw an exception if we didn't update any
<span class="pc bpc" id="L955" title="1 of 2 branches missed.">		if (rows &lt; 1) {</span>
<span class="nc" id="L956">			LOGGER.log(Level.INFO, &quot;[&quot; + getName()</span>
					+ &quot;] Failed to remove an association in the Product Index&quot;);
<span class="nc" id="L958">			throw new Exception(&quot;Failed to remove association&quot;);</span>
		}

<span class="fc" id="L961">		LOGGER.finer(&quot;[&quot; + getName() + &quot;] Removed associations event id=&quot;</span>
<span class="fc" id="L962">				+ eventIndexId + &quot;, productSummary source=&quot; + sid.getSource()</span>
<span class="fc" id="L963">				+ &quot;, type=&quot; + sid.getType() + &quot;, code=&quot; + sid.getCode()</span>
				+ &quot; (id=&quot; + productIndexId + &quot;)&quot;);

		// Should this method remove the summary from the event's list? Yes.
<span class="fc" id="L967">		Event updatedEvent = new Event(event);</span>
<span class="fc" id="L968">		List&lt;ProductSummary&gt; productsList = updatedEvent.getAllProducts().get(</span>
<span class="fc" id="L969">				summary.getType());</span>

		// pre 1.7.6 archive policies didn't always clean up after themselves
		// handle it gracefully
<span class="pc bpc" id="L973" title="1 of 2 branches missed.">		if (productsList != null) {</span>
			// remove all product with given source, type, and code
<span class="fc" id="L975">			Iterator&lt;ProductSummary&gt; iter = productsList.iterator();</span>
<span class="fc bfc" id="L976" title="All 2 branches covered.">			while (iter.hasNext()) {</span>
<span class="fc" id="L977">				ProductId id = iter.next().getId();</span>
<span class="fc bfc" id="L978" title="All 2 branches covered.">				if (id.isSameProduct(summary.getId())) {</span>
<span class="fc" id="L979">					iter.remove();</span>
				}
<span class="fc" id="L981">			}</span>
<span class="fc bfc" id="L982" title="All 2 branches covered.">			if (productsList.size() == 0) {</span>
				// if this was the last product of that type, remove the list
				// too
<span class="fc" id="L985">				updatedEvent.getAllProducts().remove(summary.getType());</span>
			}
<span class="fc" id="L987">		} else {</span>
<span class="nc" id="L988">			LOGGER.warning(&quot;Products list is empty for summary type &quot;</span>
<span class="nc" id="L989">					+ summary.getId().toString()</span>
					+ &quot;, when removing association&quot;);
		}
<span class="fc" id="L992">		return updatedEvent;</span>
	}

	// ____________________________________
	// Protected Methods
	// ____________________________________

	/**
	 * Query the database to get the event with the given event index id
	 *
	 * @param eventIndexId
	 * @return Event object
	 * @throws SQLException
	 * @throws InvalidProductException
	 */
	protected synchronized Event getEvent(Long eventIndexId)
			throws SQLException, InvalidProductException {
		// Create an event object with its eventIndexId set
<span class="fc" id="L1010">		Event event = new Event(eventIndexId);</span>

		// Find a list of summary index ids whose summaries are associated to
		// the given eventIndexId
<span class="fc" id="L1014">		Iterator&lt;Long&gt; summaryIndexIds = getSummaryIndexIds(eventIndexId)</span>
<span class="fc" id="L1015">				.iterator();</span>

<span class="fc bfc" id="L1017" title="All 2 branches covered.">		while (summaryIndexIds.hasNext()) {</span>
			// Create the product summary for each returned summary index id and
			// add the created summary to the event
<span class="fc" id="L1020">			Long summaryIndexId = summaryIndexIds.next();</span>
<span class="fc" id="L1021">			event.addProduct(getSummary(summaryIndexId));</span>
<span class="fc" id="L1022">		}</span>

		// Return our results. There may or may not be any products
<span class="fc" id="L1025">		return event;</span>
	}

	/**
	 * Query the database to get a list of event index ids that have products
	 * matching the given ProductIndexQuery.
	 *
	 * @param query
	 * @return List of index ids
	 * @throws Exception
	 */
	protected synchronized List&lt;Long&gt; getEventIndexIds(ProductIndexQuery query)
			throws Exception {
		// Object to return
<span class="fc" id="L1039">		List&lt;Long&gt; eventIndexIds = new LinkedList&lt;Long&gt;();</span>

<span class="fc bfc" id="L1041" title="All 2 branches covered.">		if (query == null) {</span>
			// a null query shouldn't match ALL events
<span class="fc" id="L1043">			return eventIndexIds;</span>
		}

		// Build up our clause list like always
<span class="fc" id="L1047">		List&lt;String&gt; clauses = buildProductClauses(query);</span>

		// Build the SQL Query from our ProductIndexQuery object
<span class="fc" id="L1050">		StringBuilder sql = new StringBuilder();</span>
<span class="fc" id="L1051">		sql.append(&quot;SELECT DISTINCT e.&quot;);</span>
<span class="fc" id="L1052">		sql.append(EVENT_INDEX_ID);</span>
<span class="fc" id="L1053">		sql.append(&quot; FROM &quot;);</span>
<span class="fc" id="L1054">		sql.append(SUMMARY_TABLE).append(&quot; p,&quot;);</span>
<span class="fc" id="L1055">		sql.append(EVENT_TABLE).append(&quot; e&quot;);</span>
<span class="fc" id="L1056">		sql.append(&quot; WHERE &quot;);</span>
		// this join is effectively the same as SUMMARY_EVENT_ID IS NOT NULL
<span class="fc" id="L1058">		sql.append(&quot;e.&quot;).append(EVENT_INDEX_ID).append(&quot;=p.&quot;)</span>
<span class="fc" id="L1059">				.append(SUMMARY_EVENT_ID);</span>

		// Add all appropriate where clauses
<span class="fc" id="L1062">		Iterator&lt;String&gt; clauseIter = clauses.iterator();</span>
<span class="fc bfc" id="L1063" title="All 2 branches covered.">		while (clauseIter.hasNext()) {</span>
<span class="fc" id="L1064">			sql.append(&quot; AND &quot;);</span>
<span class="fc" id="L1065">			sql.append(clauseIter.next());</span>
		}

		// Query the database.
<span class="fc" id="L1069">		Statement statement = null;</span>
<span class="fc" id="L1070">		ResultSet results = null;</span>

		try {
<span class="fc" id="L1073">			statement = verifyConnection().createStatement();</span>
<span class="fc" id="L1074">			results = statement.executeQuery(sql.toString());</span>

			// Loop over our results and add each eventIndexId to the list
<span class="fc bfc" id="L1077" title="All 2 branches covered.">			while (results.next()) {</span>
				// EVENT_INDEX_ID
<span class="fc" id="L1079">				eventIndexIds.add(Long.valueOf(results.getLong(1)));</span>
			}
		} finally {
			try {
<span class="fc" id="L1083">				results.close();</span>
<span class="nc" id="L1084">			} catch (Exception e) {</span>
<span class="fc" id="L1085">			}</span>
			try {
<span class="fc" id="L1087">				statement.close();</span>
<span class="nc" id="L1088">			} catch (Exception e) {</span>
<span class="fc" id="L1089">			}</span>
		}

		// Return our result. Note this is never null but may be empty.
<span class="fc" id="L1093">		return eventIndexIds;</span>
	}

	/**
	 * Use the index id to get a ProductSummary from the database.
	 *
	 * @param summaryIndexId
	 * @return ProductSummary pulled from the database
	 * @throws SQLException
	 * @throws InvalidProductException
	 */
	protected synchronized ProductSummary getSummary(Long summaryIndexId)
			throws SQLException, InvalidProductException {
<span class="fc" id="L1106">		ProductSummary summary = new ProductSummary();</span>
<span class="fc" id="L1107">		summary.setIndexId(summaryIndexId);</span>

		// -------------------------------------------------------------------
		// -- Add basic summary information
		// -------------------------------------------------------------------
<span class="fc" id="L1112">		ResultSet results = null;</span>

		try {
			// Query the index for raw information
<span class="fc" id="L1116">			getSummary.setLong(1, summaryIndexId);</span>
<span class="fc" id="L1117">			results = getSummary.executeQuery();</span>

			// Order of results is (taken from getSummary SQL)
			// 1) SUMMARY_PRODUCT_ID,
			// 2) SUMMARY_TYPE,
			// 3) SUMMARY_SOURCE,
			// 4) SUMMARY_CODE,
			// 5) SUMMARY_UPDATE_TIME,
			// 6) SUMMARY_EVENT_SOURCE,
			// 7) SUMMARY_EVENT_SOURCE_CODE,
			// 8) SUMMARY_EVENT_TIME,
			// 9) SUMMARY_EVENT_LATITUDE,
			// 10) SUMMARY_EVENT_LONGITUDE,
			// 11) SUMMARY_EVENT_DEPTH,
			// 12) SUMMARY_EVENT_MAGNITUDE,
			// 13) SUMMARY_VERSION,
			// 14) SUMMARY_STATUS,
			// 15) SUMMARY_TRACKER_URL,
			// 16) SUMMARY_PREFERRED

			// Parse the raw information and set the summary parameters
<span class="pc bpc" id="L1138" title="1 of 2 branches missed.">			if (results.next()) {</span>
				try {
					// SUMMARY_PRODUCT_ID
<span class="fc" id="L1141">					summary.setId(ProductId.parse(results.getString(1)));</span>
<span class="nc" id="L1142">				} catch (NullPointerException npx) {</span>
					// Product ID not allowed to be null
					// Remove from index?
<span class="nc" id="L1145">					LOGGER.log(</span>
							Level.WARNING,
							&quot;[&quot;
<span class="nc" id="L1148">									+ getName()</span>
									+ &quot;] Failed to get summary. Product ID was null, summary index id=&quot;
									+ summaryIndexId, npx);
<span class="nc" id="L1151">					throw new InvalidProductException(&quot;Product ID was null&quot;,</span>
							npx);
<span class="fc" id="L1153">				}</span>

				// Set some simple types. Null values are fine.
				try {
					// SUMMARY_EVENT_SOURCE
<span class="fc" id="L1158">					summary.setEventSource(results.getString(6));</span>
<span class="nc" id="L1159">				} catch (Exception e) {</span>
					// ignore
<span class="fc" id="L1161">				}</span>
<span class="fc bfc" id="L1162" title="All 2 branches covered.">				if (results.wasNull()) {</span>
<span class="fc" id="L1163">					summary.setEventSource(null);</span>
				}

				try {
					// SUMMARY_EVENT_SOURCE_CODE
<span class="fc" id="L1168">					summary.setEventSourceCode(results.getString(7));</span>
<span class="nc" id="L1169">				} catch (Exception e) {</span>
					// ignore
<span class="fc" id="L1171">				}</span>
<span class="fc bfc" id="L1172" title="All 2 branches covered.">				if (results.wasNull()) {</span>
<span class="fc" id="L1173">					summary.setEventSourceCode(null);</span>
				}

				try {
					// SUMMARY_EVENT_TIME
<span class="fc" id="L1178">					summary.setEventTime(new Date(results.getLong(8)));</span>
<span class="nc" id="L1179">				} catch (Exception e) {</span>
					// ignore
<span class="fc" id="L1181">				}</span>
<span class="fc bfc" id="L1182" title="All 2 branches covered.">				if (results.wasNull()) {</span>
<span class="fc" id="L1183">					summary.setEventTime(null);</span>
				}

				try {
					// SUMMARY_EVENT_LATITUDE
<span class="fc" id="L1188">					summary.setEventLatitude(new BigDecimal(results</span>
<span class="fc" id="L1189">							.getDouble(9)));</span>
<span class="nc" id="L1190">				} catch (Exception e) {</span>
					// ignore
<span class="fc" id="L1192">				}</span>
<span class="fc bfc" id="L1193" title="All 2 branches covered.">				if (results.wasNull()) {</span>
<span class="fc" id="L1194">					summary.setEventLatitude(null);</span>
				}

				try {
					// SUMMARY_EVENT_LONGITUDE
<span class="fc" id="L1199">					summary.setEventLongitude(new BigDecimal(results</span>
<span class="fc" id="L1200">							.getDouble(10)));</span>
<span class="nc" id="L1201">				} catch (Exception e) {</span>
					// ignore
<span class="fc" id="L1203">				}</span>
<span class="fc bfc" id="L1204" title="All 2 branches covered.">				if (results.wasNull()) {</span>
<span class="fc" id="L1205">					summary.setEventLongitude(null);</span>
				}

				try {
					// SUMMARY_EVENT_DEPTH
<span class="fc" id="L1210">					summary.setEventDepth(new BigDecimal(results.getDouble(11)));</span>
<span class="nc" id="L1211">				} catch (Exception e) {</span>
					// ignore
<span class="fc" id="L1213">				}</span>
<span class="fc bfc" id="L1214" title="All 2 branches covered.">				if (results.wasNull()) {</span>
<span class="fc" id="L1215">					summary.setEventDepth(null);</span>
				}

				try {
					// SUMMARY_EVENT_MAGNITUDE
<span class="fc" id="L1220">					summary.setEventMagnitude(new BigDecimal(results</span>
<span class="fc" id="L1221">							.getDouble(12)));</span>
<span class="nc" id="L1222">				} catch (Exception e) {</span>
					// ignore
<span class="fc" id="L1224">				}</span>
<span class="fc bfc" id="L1225" title="All 2 branches covered.">				if (results.wasNull()) {</span>
<span class="fc" id="L1226">					summary.setEventMagnitude(null);</span>
				}

				// Set some more simple values
				try {
					// SUMMARY_VERSION
<span class="fc" id="L1232">					summary.setVersion(results.getString(13));</span>
<span class="nc" id="L1233">				} catch (Exception e) {</span>
					// ignore
<span class="fc" id="L1235">				}</span>
<span class="fc bfc" id="L1236" title="All 2 branches covered.">				if (results.wasNull()) {</span>
<span class="fc" id="L1237">					summary.setVersion(null);</span>
				}

				try {
					// SUMMARY_STATUS
<span class="fc" id="L1242">					summary.setStatus(results.getString(14));</span>
<span class="nc" id="L1243">				} catch (Exception e) {</span>
					// ignore
<span class="fc" id="L1245">				}</span>
<span class="pc bpc" id="L1246" title="1 of 2 branches missed.">				if (results.wasNull()) {</span>
<span class="nc" id="L1247">					summary.setStatus(null);</span>
				}

				try {
					// SUMMARY_TRACKER_URL
<span class="fc" id="L1252">					summary.setTrackerURL(new URL(results.getString(15)));</span>
<span class="nc" id="L1253">				} catch (MalformedURLException mux) {</span>

					// Tracker URL is not allowed to be null
					// Log a message?
					// Remove this product from the index?

					// Throw a more informative exception
<span class="nc" id="L1260">					LOGGER.log(Level.INFO, &quot;[&quot; + getName()</span>
							+ &quot;] Bad TrackerURL value&quot;, mux);
<span class="nc" id="L1262">					throw new InvalidProductException(&quot;[&quot; + getName()</span>
							+ &quot;] Bad TrackerURL value&quot;, mux);
<span class="fc" id="L1264">				}</span>

				// This will default to 0 if not set in index db
				// SUMMARY_PREFERRED
<span class="fc" id="L1268">				summary.setPreferredWeight(results.getLong(16));</span>
			}
		} finally {
			// must close result set to keep from blocking transaction
			try {
<span class="fc" id="L1273">				results.close();</span>
<span class="nc" id="L1274">			} catch (Exception e) {</span>
<span class="fc" id="L1275">			}</span>
		}

		// Add summary link information
<span class="fc" id="L1279">		summary.setLinks(getSummaryLinks(summaryIndexId));</span>

		// Add summary property information
<span class="fc" id="L1282">		Map&lt;String, String&gt; properties = getSummaryProperties(summaryIndexId);</span>
<span class="fc" id="L1283">		summary.setProperties(properties);</span>

		// set numeric attributes based on string values to preserve original precision
<span class="fc bfc" id="L1286" title="All 2 branches covered.">		if (properties.containsKey(Product.DEPTH_PROPERTY)) {</span>
<span class="fc" id="L1287">			summary.setEventDepth(new BigDecimal(</span>
<span class="fc" id="L1288">					properties.get(Product.DEPTH_PROPERTY)));</span>
		}
<span class="fc bfc" id="L1290" title="All 2 branches covered.">		if (properties.containsKey(Product.LATITUDE_PROPERTY)) {</span>
<span class="fc" id="L1291">			summary.setEventLatitude(new BigDecimal(</span>
<span class="fc" id="L1292">					properties.get(Product.LATITUDE_PROPERTY)));</span>
		}
<span class="fc bfc" id="L1294" title="All 2 branches covered.">		if (properties.containsKey(Product.LONGITUDE_PROPERTY)) {</span>
<span class="fc" id="L1295">			summary.setEventLongitude(new BigDecimal(</span>
<span class="fc" id="L1296">					properties.get(Product.LONGITUDE_PROPERTY)));</span>
		}
<span class="fc bfc" id="L1298" title="All 2 branches covered.">		if (properties.containsKey(Product.MAGNITUDE_PROPERTY)) {</span>
<span class="fc" id="L1299">			summary.setEventMagnitude(new BigDecimal(</span>
<span class="fc" id="L1300">					properties.get(Product.MAGNITUDE_PROPERTY)));</span>
		}

		// Return our generated result. Note this is never null.
<span class="fc" id="L1304">		return summary;</span>
	}

	/**
	 * Use the event index id to get a list of all of the product summary ids
	 * associated with that event
	 *
	 * @param eventIndexId
	 * @return List of product index ids
	 * @throws SQLException
	 */
	protected synchronized List&lt;Long&gt; getSummaryIndexIds(Long eventIndexId)
			throws SQLException {
		// Create a list object to return
<span class="fc" id="L1318">		List&lt;Long&gt; summaryIndexIds = new LinkedList&lt;Long&gt;();</span>

<span class="fc" id="L1320">		ResultSet results = null;</span>

		try {
			// Query database for a list of product summary index ids
<span class="fc" id="L1324">			getSummaries.setLong(1, eventIndexId.longValue());</span>
<span class="fc" id="L1325">			results = getSummaries.executeQuery();</span>

			// Add each product summary index id to our list
<span class="fc bfc" id="L1328" title="All 2 branches covered.">			while (results.next()) {</span>
				// SUMMARY_PRODUCT_INDEX_ID
<span class="fc" id="L1330">				summaryIndexIds.add(Long.valueOf(results.getLong(1)));</span>
			}
		} finally {
			// must close result set to keep from blocking transaction
			try {
<span class="fc" id="L1335">				results.close();</span>
<span class="nc" id="L1336">			} catch (Exception e) {</span>
<span class="fc" id="L1337">			}</span>
		}

		// Return our results. Note this is never null but may be empty.
<span class="fc" id="L1341">		return summaryIndexIds;</span>
	}

	/**
	 * Query the database for a list of product summary index ids for summaries
	 * that match the given query.
	 *
	 * @param query
	 * @return List of product index ids
	 * @throws SQLException
	 */
	protected synchronized List&lt;Long&gt; getSummaryIndexIds(ProductIndexQuery query)
			throws SQLException {
		// Object to return
<span class="fc" id="L1355">		List&lt;Long&gt; summaryIndexIds = new LinkedList&lt;Long&gt;();</span>

		// Build up our clause list like always
<span class="fc" id="L1358">		List&lt;String&gt; clauses = buildProductClauses(query);</span>

		// Build the SQL Query from our ProductIndexQuery object
<span class="fc" id="L1361">		StringBuilder sql = new StringBuilder();</span>
<span class="fc" id="L1362">		sql.append(&quot;SELECT DISTINCT &quot;);</span>
<span class="fc" id="L1363">		sql.append(SUMMARY_PRODUCT_INDEX_ID);</span>
<span class="fc" id="L1364">		sql.append(&quot; FROM &quot;);</span>
<span class="fc" id="L1365">		sql.append(SUMMARY_TABLE).append(&quot; &quot;).append(SUMMARY_TABLE_ALIAS);</span>
<span class="fc" id="L1366">		sql.append(&quot; WHERE &quot;);</span>
<span class="fc" id="L1367">		sql.append(SUMMARY_TABLE_ALIAS).append(&quot;.&quot;)</span>
<span class="fc" id="L1368">				.append(SUMMARY_PRODUCT_INDEX_ID);</span>
<span class="fc" id="L1369">		sql.append(&quot; IS NOT NULL&quot;);</span>

		// Add all appropriate where clauses
<span class="fc" id="L1372">		Iterator&lt;String&gt; clauseIter = clauses.iterator();</span>
<span class="fc bfc" id="L1373" title="All 2 branches covered.">		while (clauseIter.hasNext()) {</span>
<span class="fc" id="L1374">			sql.append(&quot; AND &quot;);</span>
<span class="fc" id="L1375">			sql.append(clauseIter.next());</span>
		}

<span class="fc" id="L1378">		String orderBy = query.getOrderBy();</span>
<span class="pc bpc" id="L1379" title="1 of 2 branches missed.">		if (orderBy != null) {</span>
<span class="nc" id="L1380">			sql.append(&quot; ORDER BY &quot; + orderBy);</span>
		}

<span class="fc" id="L1383">		Integer limit = query.getLimit();</span>
<span class="pc bpc" id="L1384" title="1 of 2 branches missed.">		if (limit != null) {</span>
<span class="nc" id="L1385">			sql.append(&quot; LIMIT &quot; + limit);</span>
		}

<span class="fc" id="L1388">		Statement statement = null;</span>
<span class="fc" id="L1389">		ResultSet results = null;</span>
		try {
<span class="fc" id="L1391">			LOGGER.finest(&quot;[&quot; + getName() + &quot;] running query \n&quot;</span>
<span class="fc" id="L1392">					+ sql.toString());</span>
			// Query the database.
<span class="fc" id="L1394">			statement = verifyConnection().createStatement();</span>
<span class="fc" id="L1395">			results = statement.executeQuery(sql.toString());</span>

			// Loop over our results and add each eventIndexId to the list
<span class="fc bfc" id="L1398" title="All 2 branches covered.">			while (results.next()) {</span>
				// SUMMARY_PRODUCT_INDEX_ID
<span class="fc" id="L1400">				summaryIndexIds.add(Long.valueOf(results.getLong(1)));</span>
			}

<span class="fc" id="L1403">			LOGGER.finest(&quot;[&quot; + getName() + &quot;] query complete&quot;);</span>
<span class="nc" id="L1404">		} catch (Exception e) {</span>
<span class="nc" id="L1405">			LOGGER.log(Level.WARNING, &quot;[&quot; + getName()</span>
					+ &quot;] exception querying index&quot;, e);
		} finally {
			// must close result set to keep from blocking transaction
			try {
<span class="fc" id="L1410">				results.close();</span>
<span class="nc" id="L1411">			} catch (Exception e) {</span>
<span class="fc" id="L1412">			}</span>
			try {
<span class="fc" id="L1414">				statement.close();</span>
<span class="nc" id="L1415">			} catch (Exception e) {</span>
<span class="fc" id="L1416">			}</span>
		}

		// Return our result. Note this is never null but may be empty.
<span class="fc" id="L1420">		return summaryIndexIds;</span>
	}

	/**
	 * Build a list of all the pieces of the WHERE clause relevant to the
	 * productSummary table. If the query doesn't set any properties, this
	 * method will return an empty list. It is up to the calling methods to
	 * check if the clause list is empty when they build their WHERE clause.
	 *
	 * @param query
	 * @return list containing clauses in the form: column=&quot;value&quot;
	 */
	protected List&lt;String&gt; buildProductClauses(ProductIndexQuery query) {
<span class="fc" id="L1433">		List&lt;String&gt; clauseList = new ArrayList&lt;String&gt;();</span>

<span class="pc bpc" id="L1435" title="1 of 2 branches missed.">		if (query == null) {</span>
<span class="nc" id="L1436">			return clauseList; /* No query = No clauses */</span>
		}

		// If they only want current products make a clause that contains a
		// subquery
<span class="fc bfc" id="L1441" title="All 2 branches covered.">		if (query.getResultType() == ProductIndexQuery.RESULT_TYPE_CURRENT) {</span>
			String queryCode,
					querySource,
					queryType;

<span class="fc" id="L1446">			queryCode = query.getProductCode();</span>
<span class="fc" id="L1447">			querySource = query.getProductSource();</span>
<span class="fc" id="L1448">			queryType = query.getProductType();</span>

<span class="pc bpc" id="L1450" title="2 of 6 branches missed.">			if (queryCode != null &amp;&amp; querySource != null &amp;&amp; queryType != null) {</span>
				// Better sub-select when these properties are specified
<span class="fc" id="L1452">				clauseList</span>
<span class="fc" id="L1453">						.add(String</span>
<span class="fc" id="L1454">								.format(&quot;%s.%s = (SELECT %s FROM %s ps WHERE ps.%s='%s' AND ps.%s='%s' AND ps.%s='%s' AND ps.%s &lt;&gt; 'DELETE' ORDER BY ps.%s DESC LIMIT 1)&quot;,</span>
										SUMMARY_TABLE_ALIAS, SUMMARY_PRODUCT_INDEX_ID,
										SUMMARY_PRODUCT_INDEX_ID, SUMMARY_TABLE,
										SUMMARY_SOURCE, querySource,
										SUMMARY_TYPE, queryType,
										SUMMARY_CODE, queryCode,
										SUMMARY_STATUS,
										SUMMARY_UPDATE_TIME));
			} else {
<span class="fc" id="L1463">				clauseList</span>
<span class="fc" id="L1464">						.add(String</span>
<span class="fc" id="L1465">								.format(&quot;NOT EXISTS (SELECT %s FROM %s ps WHERE ps.%s=p.%s AND ps.%s=p.%s AND ps.%s=p.%s AND ps.%s &gt; p.%s AND ps.%s &lt;&gt; 'DELETE')&quot;,</span>
										SUMMARY_PRODUCT_INDEX_ID, SUMMARY_TABLE,
										SUMMARY_TYPE, SUMMARY_TYPE, SUMMARY_SOURCE,
										SUMMARY_SOURCE, SUMMARY_CODE, SUMMARY_CODE,
										SUMMARY_UPDATE_TIME, SUMMARY_UPDATE_TIME,
										SUMMARY_STATUS));
			}
<span class="fc" id="L1472">		}</span>
		// If they only want superseded products, make a slightly different
		// clause that has a subquery
<span class="fc bfc" id="L1475" title="All 2 branches covered.">		else if (query.getResultType() == ProductIndexQuery.RESULT_TYPE_SUPERSEDED) {</span>
<span class="fc" id="L1476">			clauseList</span>
<span class="fc" id="L1477">					.add(String</span>
<span class="fc" id="L1478">							.format(&quot;EXISTS (SELECT %s FROM %s ps WHERE ps.%s=p.%s AND ps.%s=p.%s AND ps.%s=p.%s AND ps.%s &gt; p.%s AND ps.%s &lt;&gt; 'DELETE')&quot;,</span>
									SUMMARY_PRODUCT_INDEX_ID, SUMMARY_TABLE,
									SUMMARY_TYPE, SUMMARY_TYPE, SUMMARY_SOURCE,
									SUMMARY_SOURCE, SUMMARY_CODE, SUMMARY_CODE,
									SUMMARY_UPDATE_TIME, SUMMARY_UPDATE_TIME,
									SUMMARY_STATUS));
		}

		// Interested in &quot;any&quot; productId in the query.
<span class="fc" id="L1487">		Iterator&lt;ProductId&gt; productIter = query.getProductIds().iterator();</span>

		// If there are one or more productIds we should build this clause
<span class="fc bfc" id="L1490" title="All 2 branches covered.">		if (productIter.hasNext()) {</span>
			// Begin an &quot;IN&quot; clause
<span class="fc" id="L1492">			StringBuilder clause = new StringBuilder();</span>
<span class="fc" id="L1493">			clause.append(String.format(&quot;%s.%s IN ('%s&quot;, SUMMARY_TABLE_ALIAS,</span>
<span class="fc" id="L1494">					SUMMARY_PRODUCT_ID, productIter.next().toString()));</span>

			// Loop over any remaining productIds and add them to clause
<span class="pc bpc" id="L1497" title="1 of 2 branches missed.">			while (productIter.hasNext()) {</span>
<span class="nc" id="L1498">				clause.append(&quot;', '&quot;);</span>
<span class="nc" id="L1499">				clause.append(productIter.next().toString());</span>
			}

			// Finish off our clause and add it to our clauseList
<span class="fc" id="L1503">			clause.append(&quot;')&quot;);</span>
<span class="fc" id="L1504">			clauseList.add(clause.toString());</span>
		}

		// Build clauses for all specified columns
<span class="fc" id="L1508">		String eventSource = query.getEventSource();</span>
<span class="fc bfc" id="L1509" title="All 2 branches covered.">		if (eventSource != null) {</span>
<span class="fc" id="L1510">			clauseList.add(String.format(&quot;%s.%s='%s'&quot;, SUMMARY_TABLE_ALIAS,</span>
					SUMMARY_EVENT_SOURCE, eventSource));
		}

<span class="fc" id="L1514">		String eventSourceCode = query.getEventSourceCode();</span>
<span class="fc bfc" id="L1515" title="All 2 branches covered.">		if (eventSourceCode != null) {</span>
<span class="fc" id="L1516">			clauseList.add(String.format(&quot;%s.%s='%s'&quot;, SUMMARY_TABLE_ALIAS,</span>
					SUMMARY_EVENT_SOURCE_CODE, eventSourceCode));
		}

		String eventTimeColumn;
		String eventLatitudeColumn;
		String eventLongitudeColumn;
		String eventMagnitudeColumn;
		String eventDepthColumn;

		// which table is used for event properties
<span class="fc bfc" id="L1527" title="All 2 branches covered.">		if (query.getEventSearchType() == ProductIndexQuery.SEARCH_EVENT_PREFERRED) {</span>
			// search preferred event parameters in event table
<span class="fc" id="L1529">			eventTimeColumn = EVENT_TABLE_ALIAS + &quot;.&quot; + EVENT_TIME;</span>
<span class="fc" id="L1530">			eventLatitudeColumn = EVENT_TABLE_ALIAS + &quot;.&quot; + EVENT_LATITUDE;</span>
<span class="fc" id="L1531">			eventLongitudeColumn = EVENT_TABLE_ALIAS + &quot;.&quot; + EVENT_LONGITUDE;</span>
<span class="fc" id="L1532">			eventMagnitudeColumn = EVENT_TABLE_ALIAS + &quot;.&quot; + EVENT_MAGNITUDE;</span>
<span class="fc" id="L1533">			eventDepthColumn = EVENT_TABLE_ALIAS + &quot;.&quot; + EVENT_DEPTH;</span>
		} else {
			// search product summary parameters in summary table
<span class="fc" id="L1536">			eventTimeColumn = SUMMARY_TABLE_ALIAS + &quot;.&quot; + SUMMARY_EVENT_TIME;</span>
<span class="fc" id="L1537">			eventLatitudeColumn = SUMMARY_TABLE_ALIAS + &quot;.&quot;</span>
					+ SUMMARY_EVENT_LATITUDE;
<span class="fc" id="L1539">			eventLongitudeColumn = SUMMARY_TABLE_ALIAS + &quot;.&quot;</span>
					+ SUMMARY_EVENT_LONGITUDE;
<span class="fc" id="L1541">			eventMagnitudeColumn = SUMMARY_TABLE_ALIAS + &quot;.&quot;</span>
					+ SUMMARY_EVENT_MAGNITUDE;
<span class="fc" id="L1543">			eventDepthColumn = SUMMARY_TABLE_ALIAS + &quot;.&quot; + SUMMARY_EVENT_DEPTH;</span>
		}

<span class="fc" id="L1546">		Date minTime = query.getMinEventTime();</span>
<span class="fc bfc" id="L1547" title="All 2 branches covered.">		if (minTime != null) {</span>
<span class="fc" id="L1548">			clauseList.add(String.format(&quot;%s&gt;=%d&quot;, eventTimeColumn,</span>
<span class="fc" id="L1549">					minTime.getTime()));</span>
		}
<span class="fc" id="L1551">		Date maxTime = query.getMaxEventTime();</span>
<span class="fc bfc" id="L1552" title="All 2 branches covered.">		if (maxTime != null) {</span>
<span class="fc" id="L1553">			clauseList.add(String.format(&quot;%s&lt;=%d&quot;, eventTimeColumn,</span>
<span class="fc" id="L1554">					maxTime.getTime()));</span>
		}

<span class="fc" id="L1557">		BigDecimal minLat = query.getMinEventLatitude();</span>
<span class="fc bfc" id="L1558" title="All 2 branches covered.">		if (minLat != null) {</span>
<span class="fc" id="L1559">			clauseList.add(String.format(&quot;%s&gt;=%f&quot;, eventLatitudeColumn,</span>
<span class="fc" id="L1560">					minLat.doubleValue()));</span>
		}
<span class="fc" id="L1562">		BigDecimal maxLat = query.getMaxEventLatitude();</span>
<span class="fc bfc" id="L1563" title="All 2 branches covered.">		if (maxLat != null) {</span>
<span class="fc" id="L1564">			clauseList.add(String.format(&quot;%s&lt;=%f&quot;, eventLatitudeColumn,</span>
<span class="fc" id="L1565">					maxLat.doubleValue()));</span>
		}

<span class="fc" id="L1568">		BigDecimal minDepth = query.getMinEventDepth();</span>
<span class="pc bpc" id="L1569" title="1 of 2 branches missed.">		if (minDepth != null) {</span>
<span class="nc" id="L1570">			clauseList.add(String.format(&quot;%s&gt;=%f&quot;, eventDepthColumn,</span>
<span class="nc" id="L1571">					minDepth.doubleValue()));</span>
		}
<span class="fc" id="L1573">		BigDecimal maxDepth = query.getMaxEventDepth();</span>
<span class="pc bpc" id="L1574" title="1 of 2 branches missed.">		if (maxDepth != null) {</span>
<span class="nc" id="L1575">			clauseList.add(String.format(&quot;%s&lt;=%f&quot;, eventDepthColumn,</span>
<span class="nc" id="L1576">					maxDepth.doubleValue()));</span>
		}

<span class="fc" id="L1579">		BigDecimal minMag = query.getMinEventMagnitude();</span>
<span class="pc bpc" id="L1580" title="1 of 2 branches missed.">		if (minMag != null) {</span>
<span class="nc" id="L1581">			clauseList.add(String.format(&quot;%s&gt;=%f&quot;, eventMagnitudeColumn,</span>
<span class="nc" id="L1582">					minMag.doubleValue()));</span>
		}
<span class="fc" id="L1584">		BigDecimal maxMag = query.getMaxEventMagnitude();</span>
<span class="pc bpc" id="L1585" title="1 of 2 branches missed.">		if (maxMag != null) {</span>
<span class="nc" id="L1586">			clauseList.add(String.format(&quot;%s&lt;=%f&quot;, eventMagnitudeColumn,</span>
<span class="nc" id="L1587">					maxMag.doubleValue()));</span>
		}

<span class="fc" id="L1590">		Date minUpdateTime = query.getMinProductUpdateTime();</span>
<span class="fc bfc" id="L1591" title="All 2 branches covered.">		if (minUpdateTime != null) {</span>
<span class="fc" id="L1592">			clauseList.add(String.format(&quot;%s&gt;=%d&quot;, SUMMARY_UPDATE_TIME,</span>
<span class="fc" id="L1593">					minUpdateTime.getTime()));</span>
		}
<span class="fc" id="L1595">		Date maxUpdateTime = query.getMaxProductUpdateTime();</span>
<span class="pc bpc" id="L1596" title="1 of 2 branches missed.">		if (maxUpdateTime != null) {</span>
<span class="nc" id="L1597">			clauseList.add(String.format(&quot;%s&lt;=%d&quot;, SUMMARY_UPDATE_TIME,</span>
<span class="nc" id="L1598">					maxUpdateTime.getTime()));</span>
		}

<span class="fc" id="L1601">		String source = query.getProductSource();</span>
<span class="fc bfc" id="L1602" title="All 2 branches covered.">		if (source != null) {</span>
<span class="fc" id="L1603">			clauseList.add(String.format(&quot;%s='%s'&quot;, SUMMARY_SOURCE, source));</span>
		}

<span class="fc" id="L1606">		String type = query.getProductType();</span>
<span class="fc bfc" id="L1607" title="All 2 branches covered.">		if (type != null) {</span>
<span class="fc" id="L1608">			clauseList.add(String.format(&quot;%s='%s'&quot;, SUMMARY_TYPE, type));</span>
		}

<span class="fc" id="L1611">		String code = query.getProductCode();</span>
<span class="fc bfc" id="L1612" title="All 2 branches covered.">		if (code != null) {</span>
<span class="fc" id="L1613">			clauseList.add(String.format(&quot;%s='%s'&quot;, SUMMARY_CODE, code));</span>
		}

<span class="fc" id="L1616">		String version = query.getProductVersion();</span>
<span class="pc bpc" id="L1617" title="1 of 2 branches missed.">		if (version != null) {</span>
<span class="nc" id="L1618">			clauseList.add(String.format(&quot;%s='%s'&quot;, SUMMARY_VERSION, version));</span>
		}

<span class="fc" id="L1621">		String status = query.getProductStatus();</span>
<span class="fc bfc" id="L1622" title="All 2 branches covered.">		if (status != null) {</span>
<span class="fc" id="L1623">			clauseList.add(String.format(&quot;%s='%s'&quot;, SUMMARY_STATUS, status));</span>
		}

<span class="fc" id="L1626">		Long minProductIndexId = query.getMinProductIndexId();</span>
<span class="pc bpc" id="L1627" title="1 of 2 branches missed.">		if (minProductIndexId != null) {</span>
<span class="nc" id="L1628">			clauseList.add(String.format(&quot;%s&gt;=%d&quot;, SUMMARY_PRODUCT_INDEX_ID, minProductIndexId));</span>
		}

<span class="fc" id="L1631">		BigDecimal minLon = query.getMinEventLongitude();</span>
<span class="fc" id="L1632">		BigDecimal maxLon = query.getMaxEventLongitude();</span>
		// Normalize the longitudes between -180 and 180
<span class="fc" id="L1634">		minLon = normalizeLongitude(minLon);</span>
<span class="fc" id="L1635">		maxLon = normalizeLongitude(maxLon);</span>

<span class="pc bpc" id="L1637" title="1 of 4 branches missed.">		if (minLon != null &amp;&amp; maxLon != null) {</span>
<span class="fc bfc" id="L1638" title="All 2 branches covered.">			if (maxLon.doubleValue() &lt; minLon.doubleValue()) {</span>
				// If the normalized maxLon is less than the normalized minLon,
				// the
				// span crosses
				// the date line
<span class="fc" id="L1643">				Double minLonDouble = minLon.doubleValue();</span>
<span class="fc" id="L1644">				Double maxLonDouble = maxLon.doubleValue();</span>
				// If the range crosses the date line, split it into 2 clauses
<span class="fc" id="L1646">				String lonClause = String.format(</span>
						&quot;((%s &gt; %f AND %s &lt;= 180) OR (%s &lt; %f AND %s &gt; -180))&quot;,
						eventLongitudeColumn, minLonDouble,
						eventLongitudeColumn, eventLongitudeColumn,
						maxLonDouble, eventLongitudeColumn);
<span class="fc" id="L1651">				clauseList.add(lonClause);</span>
<span class="fc" id="L1652">			} else {</span>
<span class="fc" id="L1653">				clauseList.add(String.format(&quot;%s&gt;=%f and %s&lt;=%f&quot;,</span>
<span class="fc" id="L1654">						eventLongitudeColumn, minLon.doubleValue(),</span>
<span class="fc" id="L1655">						eventLongitudeColumn, maxLon.doubleValue()));</span>
			}
<span class="pc bpc" id="L1657" title="1 of 2 branches missed.">		} else if (minLon != null) {</span>
<span class="nc" id="L1658">			clauseList.add(String.format(&quot;%s&gt;=%f&quot;, eventLongitudeColumn,</span>
<span class="nc" id="L1659">					minLon.doubleValue()));</span>
<span class="pc bpc" id="L1660" title="1 of 2 branches missed.">		} else if (maxLon != null) {</span>
<span class="nc" id="L1661">			clauseList.add(String.format(&quot;%s&lt;=%f&quot;, eventLongitudeColumn,</span>
<span class="nc" id="L1662">					maxLon.doubleValue()));</span>
		}
<span class="fc" id="L1664">		return clauseList;</span>
	}

	/**
	 * Create the full SELECT query for the products table using the clauseList
	 * as the WHERE clause
	 *
	 * @param clauseList
	 *            List of Strings to be AND'd together in the WHERE clause
	 * @param orderby
	 *            Complete ORDER BY clause to be added after the WHERE clause
	 * @return String containing the full SELECT query
	 */
	protected String buildProductQuery(List&lt;String&gt; clauseList, String orderby) {
		// Join all the clauses into a WHERE clause
<span class="fc" id="L1679">		StringBuilder whereClause = new StringBuilder();</span>
<span class="fc" id="L1680">		String and = &quot; AND &quot;;</span>
<span class="fc" id="L1681">		boolean first = true;</span>
<span class="fc bfc" id="L1682" title="All 2 branches covered.">		for (String clause : clauseList) {</span>
<span class="fc bfc" id="L1683" title="All 2 branches covered.">			if (!first) {</span>
<span class="fc" id="L1684">				whereClause.append(and);</span>
			} else {
<span class="fc" id="L1686">				first = false;</span>
			}
<span class="fc" id="L1688">			whereClause.append(clause);</span>
<span class="fc" id="L1689">		}</span>

<span class="fc" id="L1691">		String query_prefix = String</span>
<span class="fc" id="L1692">				.format(&quot;SELECT * FROM %s p&quot;, SUMMARY_TABLE);</span>
<span class="fc" id="L1693">		String query_suffix = &quot;&quot;;</span>
<span class="pc bpc" id="L1694" title="1 of 2 branches missed.">		if (whereClause.length() &gt; 0) {</span>
<span class="fc" id="L1695">			query_suffix = String.format(&quot; WHERE %s&quot;, whereClause.toString());</span>
		}
<span class="fc" id="L1697">		String query_text = query_prefix + query_suffix + &quot; &quot; + orderby;</span>

<span class="fc" id="L1699">		return query_text;</span>
	}

	/**
	 * Create the full SELECT query for the products table using the clauseList
	 * as the WHERE clause. This method is a wrapper for
	 * {@link #buildProductQuery(List, String)} with an empty
	 * orderby string
	 *
	 * @param clauseList
	 * @return String containing the full SELECT query
	 */
	protected String buildProductQuery(List&lt;String&gt; clauseList) {
<span class="fc" id="L1712">		return buildProductQuery(clauseList, &quot;&quot;);</span>
	}

	/**
	 * Parse the next item in the result set into a ProductSummary object
	 *
	 * @param results
	 * @return ProductSummary object with attributes filled from database
	 * @throws Exception
	 */
	protected ProductSummary parseSummaryResult(ResultSet results)
			throws Exception {
<span class="fc" id="L1724">		ProductSummary p = new ProductSummary();</span>
<span class="fc" id="L1725">		p.setIndexId(results.getLong(&quot;id&quot;));</span>
<span class="fc" id="L1726">		ProductId pid = ProductId.parse(results.getString(SUMMARY_PRODUCT_ID));</span>
<span class="fc" id="L1727">		p.setId(pid);</span>
<span class="fc" id="L1728">		p.setEventSource(results.getString(SUMMARY_EVENT_SOURCE));</span>
<span class="fc" id="L1729">		p.setEventSourceCode(results.getString(SUMMARY_EVENT_SOURCE_CODE));</span>
<span class="fc" id="L1730">		p.setEventTime(new Date(results.getLong(SUMMARY_EVENT_TIME)));</span>

		// getDouble() returns 0 if the value was actually NULL. In this case,
		// we are going to set the value to null
<span class="fc" id="L1734">		String latitude = results.getString(SUMMARY_EVENT_LATITUDE);</span>
<span class="pc bpc" id="L1735" title="1 of 2 branches missed.">		if (latitude == null) {</span>
<span class="fc" id="L1736">			p.setEventLatitude(null);</span>
		} else {
<span class="nc" id="L1738">			p.setEventLatitude(new BigDecimal(latitude));</span>
		}
<span class="fc" id="L1740">		String longitude = results.getString(SUMMARY_EVENT_LONGITUDE);</span>
<span class="pc bpc" id="L1741" title="1 of 2 branches missed.">		if (longitude == null) {</span>
<span class="fc" id="L1742">			p.setEventLongitude(null);</span>
		} else {
<span class="nc" id="L1744">			p.setEventLongitude(new BigDecimal(longitude));</span>
		}
<span class="fc" id="L1746">		String depth = results.getString(SUMMARY_EVENT_DEPTH);</span>
<span class="fc bfc" id="L1747" title="All 2 branches covered.">		if (depth == null) {</span>
<span class="fc" id="L1748">			p.setEventDepth(null);</span>
		} else {
<span class="fc" id="L1750">			p.setEventDepth(new BigDecimal(depth));</span>
		}
<span class="fc" id="L1752">		String magnitude = results.getString(SUMMARY_EVENT_MAGNITUDE);</span>
<span class="fc bfc" id="L1753" title="All 2 branches covered.">		if (magnitude == null) {</span>
<span class="fc" id="L1754">			p.setEventMagnitude(null);</span>
		} else {
<span class="fc" id="L1756">			p.setEventMagnitude(new BigDecimal(magnitude));</span>
		}
<span class="fc" id="L1758">		p.setVersion(results.getString(SUMMARY_VERSION));</span>
<span class="fc" id="L1759">		p.setStatus(results.getString(SUMMARY_STATUS));</span>
<span class="pc bpc" id="L1760" title="1 of 2 branches missed.">		p.setTrackerURL((results.getString(SUMMARY_TRACKER_URL) != null) ? new URL(</span>
<span class="pc" id="L1761">				results.getString(SUMMARY_TRACKER_URL)) : null);</span>
<span class="fc" id="L1762">		p.setPreferredWeight(results.getLong(SUMMARY_PREFERRED));</span>

		// Set product links
<span class="fc" id="L1765">		Long indexId = p.getIndexId();</span>
<span class="fc" id="L1766">		ResultSet links = null;</span>
		try {
<span class="fc" id="L1768">			JDBCUtils.setParameter(getProductLinks, 1, indexId, Types.BIGINT);</span>
<span class="fc" id="L1769">			links = getProductLinks.executeQuery();</span>
<span class="fc bfc" id="L1770" title="All 2 branches covered.">			while (links.next()) {</span>
<span class="fc" id="L1771">				p.addLink(links.getString(SUMMARY_LINK_RELATION),</span>
<span class="fc" id="L1772">						new URI(links.getString(SUMMARY_LINK_URL)));</span>
			}
		} finally {
			try {
<span class="fc" id="L1776">				links.close(); // Free this result set</span>
<span class="nc" id="L1777">			} catch (Exception e) {</span>
<span class="fc" id="L1778">			}</span>
		}

<span class="fc" id="L1781">		ResultSet props = null;</span>
		try {
			// Set product properties
<span class="fc" id="L1784">			JDBCUtils.setParameter(getProductProperties, 1, indexId,</span>
					Types.BIGINT);
<span class="fc" id="L1786">			props = getProductProperties.executeQuery();</span>
<span class="fc" id="L1787">			Map&lt;String, String&gt; properties = p.getProperties();</span>
<span class="fc bfc" id="L1788" title="All 2 branches covered.">			while (props.next()) {</span>
<span class="fc" id="L1789">				properties.put(props.getString(SUMMARY_PROPERTY_NAME),</span>
<span class="fc" id="L1790">						props.getString(SUMMARY_PROPERTY_VALUE));</span>
			}
<span class="fc" id="L1792">			p.setProperties(properties);</span>
		} finally {
			try {
<span class="fc" id="L1795">				props.close();</span>
<span class="nc" id="L1796">			} catch (Exception e) {</span>
<span class="fc" id="L1797">			}</span>
		}

<span class="fc" id="L1800">		return p;</span>
	}

	/**
	 * Look in the database for all the properties associated with the given
	 * product summary.
	 *
	 * @param summaryIndexId
	 * @return Map of property name to property value
	 * @throws SQLException
	 * @throws InvalidProductException
	 */
	protected synchronized Map&lt;String, String&gt; getSummaryProperties(
			Long summaryIndexId) throws SQLException, InvalidProductException {
		// Create our object to populate and return
<span class="fc" id="L1815">		Map&lt;String, String&gt; properties = new HashMap&lt;String, String&gt;();</span>

<span class="fc" id="L1817">		ResultSet results = null;</span>
		try {
<span class="fc" id="L1819">			getProductProperties.setLong(1, summaryIndexId.longValue());</span>
<span class="fc" id="L1820">			results = getProductProperties.executeQuery();</span>
<span class="fc bfc" id="L1821" title="All 2 branches covered.">			while (results.next()) {</span>
				// SUMMARY_PROPERTY_NAME
<span class="fc" id="L1823">				String name = results.getString(1);</span>
				// SUMMARY_PROPERTY_VALUE
<span class="fc" id="L1825">				String value = results.getString(2);</span>

<span class="pc bpc" id="L1827" title="2 of 4 branches missed.">				if (name == null || value == null) {</span>

					// Both name and value are required
					// Log something?
					// Remove link from product index db?
<span class="nc" id="L1832">					InvalidProductException ipx = new InvalidProductException(</span>
							&quot;Bad Product Property&quot;);
<span class="nc" id="L1834">					ipx.fillInStackTrace();</span>
<span class="nc" id="L1835">					LOGGER.log(Level.INFO, &quot;[&quot; + getName()</span>
							+ &quot;] Bad Product Property&quot;, ipx);
<span class="nc" id="L1837">					throw ipx;</span>
				}

				// Add this link back to the map of links
<span class="fc" id="L1841">				properties.put(name, value);</span>
<span class="fc" id="L1842">			}</span>
		} finally {
			// must close result set to keep from blocking transaction
			try {
<span class="fc" id="L1846">				results.close();</span>
<span class="nc" id="L1847">			} catch (Exception e) {</span>
<span class="fc" id="L1848">			}</span>
		}
		// Return our mapping of generated properties. Note this is never null
		// but may be empty.
<span class="fc" id="L1852">		return properties;</span>
	}

	/**
	 * Save the properties in the database and associate them to the given
	 * productId
	 *
	 * @param productId
	 * @param properties
	 * @throws SQLException
	 */
	protected synchronized void addProductProperties(long productId,
			Map&lt;String, String&gt; properties) throws SQLException {
		// Loop through the properties list and add them all to the database
<span class="fc" id="L1866">		Set&lt;String&gt; keys = properties.keySet();</span>
<span class="fc bfc" id="L1867" title="All 2 branches covered.">		for (String key : keys) {</span>
<span class="fc" id="L1868">			JDBCUtils.setParameter(insertProperty, 1, productId, Types.BIGINT);</span>
<span class="fc" id="L1869">			JDBCUtils.setParameter(insertProperty, 2, key, Types.VARCHAR);</span>
<span class="fc" id="L1870">			JDBCUtils.setParameter(insertProperty, 3, properties.get(key),</span>
					Types.VARCHAR);

<span class="fc" id="L1873">			insertProperty.executeUpdate();</span>
<span class="fc bfc" id="L1874" title="All 2 branches covered.">			if (LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="fc" id="L1875">				LOGGER.log(Level.FINEST, &quot;[&quot; + getName() + &quot;] Added property &quot;</span>
<span class="fc" id="L1876">						+ key + &quot;:&quot; + properties.get(key) + &quot; for product &quot;</span>
						+ productId);
			}
<span class="fc" id="L1879">		}</span>
<span class="fc" id="L1880">	}</span>

	/**
	 * Delete the given properties from the index
	 *
	 * @param productId
	 */
	protected synchronized void removeProductProperties(long productId)
			throws Exception {
<span class="fc" id="L1889">		JDBCUtils.setParameter(deleteProperties, 1, productId, Types.BIGINT);</span>

<span class="fc" id="L1891">		deleteProperties.executeUpdate();</span>
<span class="fc" id="L1892">	}</span>

	/**
	 * Look in the database for all the links associated with the given product
	 * summary.
	 *
	 * @param summaryIndexId
	 * @return Map of link relation (link type) to URL
	 * @throws SQLException
	 * @throws InvalidProductException
	 */
	protected synchronized Map&lt;String, List&lt;URI&gt;&gt; getSummaryLinks(
			Long summaryIndexId) throws SQLException, InvalidProductException {
		// Create our object to populate and return
<span class="fc" id="L1906">		Map&lt;String, List&lt;URI&gt;&gt; links = new HashMap&lt;String, List&lt;URI&gt;&gt;();</span>

<span class="fc" id="L1908">		ResultSet results = null;</span>
		try {
<span class="fc" id="L1910">			getProductLinks.setLong(1, summaryIndexId.longValue());</span>
<span class="fc" id="L1911">			results = getProductLinks.executeQuery();</span>

<span class="fc bfc" id="L1913" title="All 2 branches covered.">			while (results.next()) {</span>
				// SUMMARY_LINK_RELATION
<span class="fc" id="L1915">				String relation = results.getString(1);</span>
				// SUMMARY_LINK_URL
<span class="fc" id="L1917">				String uriStr = results.getString(2);</span>

<span class="pc bpc" id="L1919" title="2 of 4 branches missed.">				if (relation == null || uriStr == null) {</span>

					// Both relation and uri are required
					// Log something?
					// Remove link from product index db?

<span class="nc" id="L1925">					InvalidProductException ipx = new InvalidProductException(</span>
<span class="nc" id="L1926">							&quot;[&quot; + getName() + &quot;] Bad Product Link&quot;);</span>
<span class="nc" id="L1927">					ipx.fillInStackTrace();</span>
<span class="nc" id="L1928">					LOGGER.log(Level.INFO, &quot;[&quot; + getName()</span>
							+ &quot;] Bad Product link&quot;, ipx);
<span class="nc" id="L1930">					throw ipx;</span>
				}
<span class="fc" id="L1932">				List&lt;URI&gt; l = links.get(relation);</span>

				// Case when no links for this relation yet
<span class="pc bpc" id="L1935" title="1 of 2 branches missed.">				if (l == null) {</span>
<span class="fc" id="L1936">					l = new LinkedList&lt;URI&gt;();</span>
				}

				try {
<span class="fc" id="L1940">					l.add(new URI(uriStr));</span>
<span class="nc" id="L1941">				} catch (URISyntaxException usx) {</span>

					// Link URI String in DB was malformed.
					// Log something?
					// Remove from index?
<span class="nc" id="L1946">					LOGGER.log(Level.INFO, &quot;[&quot; + getName()</span>
							+ &quot;] Bad Product Link&quot;, usx);
<span class="nc" id="L1948">					throw new InvalidProductException(&quot;[&quot; + getName()</span>
							+ &quot;] Bad Product Link&quot;, usx);
<span class="fc" id="L1950">				}</span>

				// Add this link back to the map of links
<span class="fc" id="L1953">				links.put(relation, l);</span>
<span class="fc" id="L1954">			}</span>
		} finally {
			// must close result set to keep from blocking transaction
			try {
<span class="fc" id="L1958">				results.close();</span>
<span class="nc" id="L1959">			} catch (Exception e) {</span>
<span class="fc" id="L1960">			}</span>
		}
		// Return our mapping of generated links. Note this is never null but
		// may be empty.
<span class="fc" id="L1964">		return links;</span>
	}

	/**
	 * Save the links in the database and associate them to the given productId
	 *
	 * @param productId
	 *            Index id of the product to select
	 * @param links
	 *            Map of relations to URIs
	 * @throws SQLException
	 */
	protected synchronized void addProductLinks(long productId,
			Map&lt;String, List&lt;URI&gt;&gt; links) throws SQLException {
		// Loop through the properties list and add them all to the database
<span class="fc" id="L1979">		Set&lt;String&gt; keys = links.keySet();</span>
<span class="fc bfc" id="L1980" title="All 2 branches covered.">		for (String key : keys) {</span>
<span class="fc" id="L1981">			List&lt;URI&gt; uris = links.get(key);</span>
<span class="fc bfc" id="L1982" title="All 2 branches covered.">			for (URI uri : uris) {</span>
<span class="fc" id="L1983">				JDBCUtils.setParameter(insertLink, 1, productId, Types.BIGINT);</span>
<span class="fc" id="L1984">				JDBCUtils.setParameter(insertLink, 2, key, Types.VARCHAR);</span>
<span class="fc" id="L1985">				JDBCUtils.setParameter(insertLink, 3, uri.toString(),</span>
						Types.VARCHAR);

<span class="fc" id="L1988">				insertLink.executeUpdate();</span>
<span class="fc" id="L1989">				LOGGER.log(Level.FINEST, &quot;[&quot; + getName() + &quot;] Added link &quot;</span>
<span class="fc" id="L1990">						+ key + &quot;:&quot; + uri.toString() + &quot; for product &quot;</span>
						+ productId);
<span class="fc" id="L1992">			}</span>
<span class="fc" id="L1993">		}</span>
<span class="fc" id="L1994">	}</span>

	/**
	 * Delete the given links from the index
	 *
	 * @param productId
	 */
	protected synchronized void removeProductLinks(long productId)
			throws Exception {
<span class="fc" id="L2003">		JDBCUtils.setParameter(deleteLinks, 1, productId, Types.BIGINT);</span>

<span class="fc" id="L2005">		deleteLinks.executeUpdate();</span>
<span class="fc" id="L2006">	}</span>

	/**
	 * Convert the given longitude to be between -180 and 180. If the given
	 * value is already in the range, this method just returns the value.
	 *
	 * @param lon
	 * @return double normalized between -180 and 180
	 */
	protected double normalizeLongitude(double lon) {
<span class="fc" id="L2016">		double normalizedLon = lon;</span>

<span class="fc bfc" id="L2018" title="All 4 branches covered.">		if (normalizedLon &lt;= 180 &amp;&amp; normalizedLon &gt; -180) {</span>
<span class="fc" id="L2019">			return normalizedLon;</span>
		}

		// If the value is above 180, make it negative by subtracting 360
<span class="fc bfc" id="L2023" title="All 2 branches covered.">		if (normalizedLon &gt; 180) {</span>
<span class="fc" id="L2024">			normalizedLon = normalizedLon % 360;</span>
<span class="fc" id="L2025">			normalizedLon = normalizedLon - 360;</span>
<span class="fc" id="L2026">			return normalizedLon;</span>
		}

		// If the value is below 180, make it positive by adding 360
<span class="pc bpc" id="L2030" title="1 of 2 branches missed.">		if (normalizedLon &lt;= -180) {</span>
<span class="fc" id="L2031">			normalizedLon = normalizedLon % 360;</span>
<span class="fc" id="L2032">			normalizedLon = normalizedLon + 360;</span>
<span class="fc" id="L2033">			return normalizedLon;</span>
		}

<span class="nc" id="L2036">		return normalizedLon;</span>
	}

	/**
	 * Wrapper to normalize BigDecimal longitudes
	 *
	 * @param lon
	 * @return Normalized BigDecimal latitude
	 */
	protected BigDecimal normalizeLongitude(BigDecimal lon) {
<span class="fc bfc" id="L2046" title="All 2 branches covered.">		if (lon == null) {</span>
<span class="fc" id="L2047">			return null;</span>
		}

<span class="fc" id="L2050">		return new BigDecimal(normalizeLongitude(lon.doubleValue()));</span>
	}

	/**
	 * Called when the indexer is done updating events after a product is
	 * processed. Stores the preferred attributes for each event in the list
	 *
	 * @param events
	 *            the events that have been updated.
	 */
	@Override
	public synchronized void eventsUpdated(List&lt;Event&gt; events) throws Exception {
<span class="fc" id="L2062">		Long indexId = null;</span>

<span class="fc" id="L2064">		Iterator&lt;Event&gt; iter = events.iterator();</span>
<span class="fc bfc" id="L2065" title="All 2 branches covered.">		while (iter.hasNext()) {</span>
<span class="fc" id="L2066">			Event updated = iter.next();</span>

<span class="fc" id="L2068">			LOGGER.finer(&quot;[&quot; + getName() + &quot;] Updating event indexid=&quot;</span>
<span class="fc" id="L2069">					+ updated.getIndexId());</span>
<span class="fc" id="L2070">			updated.log(LOGGER);</span>

			try {
<span class="fc" id="L2073">				indexId = updated.getIndexId();</span>

<span class="fc bfc" id="L2075" title="All 2 branches covered.">				if (updated.isDeleted()) {</span>
					// only update status if event deleted, leave other
					// parameters intact
<span class="fc" id="L2078">					JDBCUtils.setParameter(updateDeletedEvent, 1,</span>
							EVENT_STATUS_DELETE, Types.VARCHAR);
<span class="fc" id="L2080">					JDBCUtils.setParameter(updateDeletedEvent, 2, indexId,</span>
							Types.BIGINT);

<span class="fc" id="L2083">					updateDeletedEvent.executeUpdate();</span>
				} else {
<span class="fc" id="L2085">					EventSummary summary = updated.getEventSummary();</span>

					// otherwise update event parameters
<span class="fc" id="L2088">					JDBCUtils.setParameter(updateEvent, 1,</span>
<span class="fc" id="L2089">							new Date().getTime(), Types.BIGINT);</span>
<span class="fc" id="L2090">					JDBCUtils.setParameter(updateEvent, 2, summary.getSource(),</span>
							Types.VARCHAR);
<span class="fc" id="L2092">					JDBCUtils.setParameter(updateEvent, 3,</span>
<span class="fc" id="L2093">							summary.getSourceCode(), Types.VARCHAR);</span>

<span class="fc" id="L2095">					Long eventTime = null;</span>
<span class="pc bpc" id="L2096" title="1 of 2 branches missed.">					if (summary.getTime() != null) {</span>
<span class="fc" id="L2097">						eventTime = summary.getTime().getTime();</span>
					}
<span class="fc" id="L2099">					JDBCUtils.setParameter(updateEvent, 4, eventTime,</span>
							Types.BIGINT);

<span class="fc" id="L2102">					Double latitude = null;</span>
<span class="pc bpc" id="L2103" title="1 of 2 branches missed.">					if (summary.getLatitude() != null) {</span>
<span class="fc" id="L2104">						latitude = summary.getLatitude().doubleValue();</span>
					}
<span class="fc" id="L2106">					JDBCUtils.setParameter(updateEvent, 5, latitude,</span>
							Types.DOUBLE);

<span class="fc" id="L2109">					Double longitude = null;</span>
<span class="pc bpc" id="L2110" title="1 of 2 branches missed.">					if (summary.getLongitude() != null) {</span>
<span class="fc" id="L2111">						longitude = summary.getLongitude().doubleValue();</span>
					}
<span class="fc" id="L2113">					JDBCUtils.setParameter(updateEvent, 6, longitude,</span>
							Types.DOUBLE);

					// these may be null, handle carefully
<span class="fc" id="L2117">					Double depth = null;</span>
<span class="fc bfc" id="L2118" title="All 2 branches covered.">					if (summary.getDepth() != null) {</span>
<span class="fc" id="L2119">						depth = summary.getDepth().doubleValue();</span>
					}
<span class="fc" id="L2121">					JDBCUtils.setParameter(updateEvent, 7, depth, Types.DOUBLE);</span>

<span class="fc" id="L2123">					Double magnitude = null;</span>
<span class="fc bfc" id="L2124" title="All 2 branches covered.">					if (summary.getMagnitude() != null) {</span>
<span class="fc" id="L2125">						magnitude = summary.getMagnitude().doubleValue();</span>
					}
<span class="fc" id="L2127">					JDBCUtils.setParameter(updateEvent, 8, magnitude,</span>
							Types.DOUBLE);

<span class="fc" id="L2130">					JDBCUtils.setParameter(updateEvent, 9, EVENT_STATUS_UPDATE,</span>
							Types.VARCHAR);

<span class="fc" id="L2133">					JDBCUtils.setParameter(updateEvent, 10, indexId,</span>
							Types.BIGINT);

<span class="fc" id="L2136">					updateEvent.executeUpdate();</span>
				}

<span class="fc" id="L2139">				LOGGER.log(Level.FINEST, &quot;[&quot; + getName()</span>
						+ &quot;] Updated event properties in Product Index&quot;);
<span class="nc" id="L2141">			} catch (Exception e) {</span>
<span class="nc" id="L2142">				LOGGER.log(Level.WARNING, &quot;[&quot; + getName()</span>
						+ &quot;] Error updating event properties, eventid=&quot;
						+ indexId, e);
				// trigger a rollback
<span class="nc" id="L2146">				throw e;</span>
<span class="fc" id="L2147">			}</span>
<span class="fc" id="L2148">		}</span>
<span class="fc" id="L2149">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>